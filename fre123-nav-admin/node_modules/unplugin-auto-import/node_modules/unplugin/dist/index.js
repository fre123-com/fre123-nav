var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toESM = (module2, isNodeMode) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", !isNodeMode && module2 && module2.__esModule ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  createUnplugin: () => createUnplugin
});

// node_modules/.pnpm/tsup@5.11.13_typescript@4.6.2/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL("file:" + __filename).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/esbuild/index.ts
var import_fs = __toESM(require("fs"));
var import_path2 = __toESM(require("path"));
var import_chokidar = __toESM(require("chokidar"));

// src/esbuild/utils.ts
var import_path = require("path");

// node_modules/.pnpm/@jridgewell+sourcemap-codec@1.4.11/node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs
var comma = ",".charCodeAt(0);
var semicolon = ";".charCodeAt(0);
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var intToChar = new Uint8Array(64);
var charToInteger = new Uint8Array(128);
for (let i = 0; i < chars.length; i++) {
  const c = chars.charCodeAt(i);
  charToInteger[c] = i;
  intToChar[i] = c;
}
var td = typeof TextDecoder !== "undefined" ? new TextDecoder() : typeof Buffer !== "undefined" ? {
  decode(buf) {
    const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);
    return out.toString();
  }
} : {
  decode(buf) {
    let out = "";
    for (let i = 0; i < buf.length; i++) {
      out += String.fromCharCode(buf[i]);
    }
    return out;
  }
};
function decode(mappings) {
  const state = new Int32Array(5);
  const decoded = [];
  let line = [];
  let sorted = true;
  let lastCol = 0;
  for (let i = 0; i < mappings.length; ) {
    const c = mappings.charCodeAt(i);
    if (c === comma) {
      i++;
    } else if (c === semicolon) {
      state[0] = lastCol = 0;
      if (!sorted)
        sort(line);
      sorted = true;
      decoded.push(line);
      line = [];
      i++;
    } else {
      i = decodeInteger(mappings, i, state, 0);
      const col = state[0];
      if (col < lastCol)
        sorted = false;
      lastCol = col;
      if (!hasMoreSegments(mappings, i)) {
        line.push([col]);
        continue;
      }
      i = decodeInteger(mappings, i, state, 1);
      i = decodeInteger(mappings, i, state, 2);
      i = decodeInteger(mappings, i, state, 3);
      if (!hasMoreSegments(mappings, i)) {
        line.push([col, state[1], state[2], state[3]]);
        continue;
      }
      i = decodeInteger(mappings, i, state, 4);
      line.push([col, state[1], state[2], state[3], state[4]]);
    }
  }
  if (!sorted)
    sort(line);
  decoded.push(line);
  return decoded;
}
function decodeInteger(mappings, pos, state, j) {
  let value = 0;
  let shift = 0;
  let integer = 0;
  do {
    const c = mappings.charCodeAt(pos++);
    integer = charToInteger[c];
    value |= (integer & 31) << shift;
    shift += 5;
  } while (integer & 32);
  const shouldNegate = value & 1;
  value >>>= 1;
  if (shouldNegate) {
    value = -2147483648 | -value;
  }
  state[j] += value;
  return pos;
}
function hasMoreSegments(mappings, i) {
  if (i >= mappings.length)
    return false;
  const c = mappings.charCodeAt(i);
  if (c === comma || c === semicolon)
    return false;
  return true;
}
function sort(line) {
  line.sort(sortComparator);
}
function sortComparator(a, b) {
  return a[0] - b[0];
}
function encode(decoded) {
  const state = new Int32Array(5);
  let buf = new Uint8Array(1024);
  let pos = 0;
  for (let i = 0; i < decoded.length; i++) {
    const line = decoded[i];
    if (i > 0) {
      buf = reserve(buf, pos, 1);
      buf[pos++] = semicolon;
    }
    if (line.length === 0)
      continue;
    state[0] = 0;
    for (let j = 0; j < line.length; j++) {
      const segment = line[j];
      buf = reserve(buf, pos, 36);
      if (j > 0)
        buf[pos++] = comma;
      pos = encodeInteger(buf, pos, state, segment, 0);
      if (segment.length === 1)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 1);
      pos = encodeInteger(buf, pos, state, segment, 2);
      pos = encodeInteger(buf, pos, state, segment, 3);
      if (segment.length === 4)
        continue;
      pos = encodeInteger(buf, pos, state, segment, 4);
    }
  }
  return td.decode(buf.subarray(0, pos));
}
function reserve(buf, pos, count) {
  if (buf.length > pos + count)
    return buf;
  const swap = new Uint8Array(buf.length * 2);
  swap.set(buf);
  return swap;
}
function encodeInteger(buf, pos, state, segment, j) {
  const next = segment[j];
  let num = next - state[j];
  state[j] = next;
  num = num < 0 ? -num << 1 | 1 : num << 1;
  do {
    let clamped = num & 31;
    num >>>= 5;
    if (num > 0)
      clamped |= 32;
    buf[pos++] = intToChar[clamped];
  } while (num > 0);
  return pos;
}

// node_modules/.pnpm/@jridgewell+resolve-uri@3.0.5/node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs
var schemeRegex = /^[\w+.-]+:\/\//;
var urlRegex = /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?/;
function isAbsoluteUrl(input) {
  return schemeRegex.test(input);
}
function isSchemeRelativeUrl(input) {
  return input.startsWith("//");
}
function isAbsolutePath(input) {
  return input.startsWith("/");
}
function parseAbsoluteUrl(input) {
  const match = urlRegex.exec(input);
  return {
    scheme: match[1],
    user: match[2] || "",
    host: match[3],
    port: match[4] || "",
    path: match[5] || "/",
    relativePath: false
  };
}
function parseUrl(input) {
  if (isSchemeRelativeUrl(input)) {
    const url = parseAbsoluteUrl("http:" + input);
    url.scheme = "";
    return url;
  }
  if (isAbsolutePath(input)) {
    const url = parseAbsoluteUrl("http://foo.com" + input);
    url.scheme = "";
    url.host = "";
    return url;
  }
  if (!isAbsoluteUrl(input)) {
    const url = parseAbsoluteUrl("http://foo.com/" + input);
    url.scheme = "";
    url.host = "";
    url.relativePath = true;
    return url;
  }
  return parseAbsoluteUrl(input);
}
function stripPathFilename(path2) {
  if (path2.endsWith("/.."))
    return path2;
  const index = path2.lastIndexOf("/");
  return path2.slice(0, index + 1);
}
function mergePaths(url, base) {
  if (!url.relativePath)
    return;
  normalizePath(base);
  if (url.path === "/") {
    url.path = base.path;
  } else {
    url.path = stripPathFilename(base.path) + url.path;
  }
  url.relativePath = base.relativePath;
}
function normalizePath(url) {
  const { relativePath } = url;
  const pieces = url.path.split("/");
  let pointer = 1;
  let positive = 0;
  let addTrailingSlash = false;
  for (let i = 1; i < pieces.length; i++) {
    const piece = pieces[i];
    if (!piece) {
      addTrailingSlash = true;
      continue;
    }
    addTrailingSlash = false;
    if (piece === ".")
      continue;
    if (piece === "..") {
      if (positive) {
        addTrailingSlash = true;
        positive--;
        pointer--;
      } else if (relativePath) {
        pieces[pointer++] = piece;
      }
      continue;
    }
    pieces[pointer++] = piece;
    positive++;
  }
  let path2 = "";
  for (let i = 1; i < pointer; i++) {
    path2 += "/" + pieces[i];
  }
  if (!path2 || addTrailingSlash && !path2.endsWith("/..")) {
    path2 += "/";
  }
  url.path = path2;
}
function resolve(input, base) {
  if (!input && !base)
    return "";
  const url = parseUrl(input);
  if (base && !url.scheme) {
    const baseUrl = parseUrl(base);
    url.scheme = baseUrl.scheme;
    if (!url.host || baseUrl.scheme === "file:") {
      url.user = baseUrl.user;
      url.host = baseUrl.host;
      url.port = baseUrl.port;
    }
    mergePaths(url, baseUrl);
  }
  normalizePath(url);
  if (url.relativePath) {
    const path2 = url.path.slice(1);
    if (!path2)
      return ".";
    const keepRelative = (base || input).startsWith(".");
    return !keepRelative || path2.startsWith(".") ? path2 : "./" + path2;
  }
  if (!url.scheme && !url.host)
    return url.path;
  return `${url.scheme}//${url.user}${url.host}${url.port}${url.path}`;
}

// node_modules/.pnpm/@jridgewell+trace-mapping@0.3.4/node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs
function resolve2(input, base) {
  if (base && !base.endsWith("/"))
    base += "/";
  return resolve(input, base);
}
function stripFilename(path2) {
  if (!path2)
    return "";
  const index = path2.lastIndexOf("/");
  return path2.slice(0, index + 1);
}
function maybeSort(mappings, owned) {
  const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);
  if (unsortedIndex === mappings.length)
    return mappings;
  if (!owned)
    mappings = mappings.slice();
  for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {
    mappings[i] = sortSegments(mappings[i], owned);
  }
  return mappings;
}
function nextUnsortedSegmentLine(mappings, start) {
  for (let i = start; i < mappings.length; i++) {
    if (!isSorted(mappings[i]))
      return i;
  }
  return mappings.length;
}
function isSorted(line) {
  for (let j = 1; j < line.length; j++) {
    if (line[j][0] < line[j - 1][0]) {
      return false;
    }
  }
  return true;
}
function sortSegments(line, owned) {
  if (!owned)
    line = line.slice();
  return line.sort(sortComparator2);
}
function sortComparator2(a, b) {
  return a[0] - b[0];
}
function binarySearch(haystack, needle, low, high) {
  while (low <= high) {
    const mid = low + (high - low >> 1);
    const cmp = haystack[mid][0] - needle;
    if (cmp === 0) {
      return mid;
    }
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return low - 1;
}
function memoizedState() {
  return {
    lastKey: -1,
    lastNeedle: -1,
    lastIndex: -1
  };
}
function memoizedBinarySearch(haystack, needle, state, key) {
  const { lastKey, lastNeedle, lastIndex } = state;
  let low = 0;
  let high = haystack.length - 1;
  if (key === lastKey) {
    if (needle === lastNeedle) {
      return lastIndex;
    }
    if (needle >= lastNeedle) {
      low = Math.max(lastIndex, 0);
    } else {
      high = lastIndex;
    }
  }
  state.lastKey = key;
  state.lastNeedle = needle;
  return state.lastIndex = binarySearch(haystack, needle, low, high);
}
var INVALID_MAPPING = Object.freeze({
  source: null,
  line: null,
  column: null,
  name: null
});
var encodedMappings;
var decodedMappings;
var traceSegment;
var originalPositionFor;
var eachMapping;
var presortedDecodedMap;
var TraceMap = class {
  constructor(map, mapUrl) {
    this._binarySearchMemo = memoizedState();
    const isString = typeof map === "string";
    const parsed = isString ? JSON.parse(map) : map;
    const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;
    this.version = version;
    this.file = file;
    this.names = names;
    this.sourceRoot = sourceRoot;
    this.sources = sources;
    this.sourcesContent = sourcesContent;
    if (sourceRoot || mapUrl) {
      const from = resolve2(sourceRoot || "", stripFilename(mapUrl));
      this.resolvedSources = sources.map((s) => resolve2(s || "", from));
    } else {
      this.resolvedSources = sources.map((s) => s || "");
    }
    const { mappings } = parsed;
    if (typeof mappings === "string") {
      this._encoded = mappings;
      this._decoded = decode(mappings);
    } else {
      this._encoded = void 0;
      this._decoded = maybeSort(mappings, isString);
    }
  }
};
(() => {
  encodedMappings = (map) => {
    var _a;
    return (_a = map._encoded) !== null && _a !== void 0 ? _a : map._encoded = encode(map._decoded);
  };
  decodedMappings = (map) => {
    return map._decoded;
  };
  traceSegment = (map, line, column) => {
    const decoded = map._decoded;
    if (line >= decoded.length)
      return null;
    const segments = decoded[line];
    const index = memoizedBinarySearch(segments, column, map._binarySearchMemo, line);
    if (index < 0)
      return null;
    return segments[index];
  };
  originalPositionFor = (map, { line, column }) => {
    if (line < 1)
      throw new Error("`line` must be greater than 0 (lines start at line 1)");
    if (column < 0) {
      throw new Error("`column` must be greater than or equal to 0 (columns start at column 0)");
    }
    const segment = traceSegment(map, line - 1, column);
    if (segment == null)
      return INVALID_MAPPING;
    if (segment.length == 1)
      return INVALID_MAPPING;
    const { names, resolvedSources } = map;
    return {
      source: resolvedSources[segment[1]],
      line: segment[2] + 1,
      column: segment[3],
      name: segment.length === 5 ? names[segment[4]] : null
    };
  };
  eachMapping = (map, cb) => {
    const decoded = map._decoded;
    const { names, resolvedSources } = map;
    for (let i = 0; i < decoded.length; i++) {
      const line = decoded[i];
      for (let j = 0; j < line.length; j++) {
        const seg = line[j];
        const generatedLine = i + 1;
        const generatedColumn = seg[0];
        let source = null;
        let originalLine = null;
        let originalColumn = null;
        let name = null;
        if (seg.length !== 1) {
          source = resolvedSources[seg[1]];
          originalLine = seg[2] + 1;
          originalColumn = seg[3];
        }
        if (seg.length === 5)
          name = names[seg[4]];
        cb({
          generatedLine,
          generatedColumn,
          source,
          originalLine,
          originalColumn,
          name
        });
      }
    }
  };
  presortedDecodedMap = (map, mapUrl) => {
    const clone = Object.assign({}, map);
    clone.mappings = [];
    const tracer = new TraceMap(clone, mapUrl);
    tracer._decoded = map.mappings;
    return tracer;
  };
})();

// node_modules/.pnpm/@ampproject+remapping@2.1.2/node_modules/@ampproject/remapping/dist/remapping.mjs
var OriginalSource = class {
  constructor(source, content) {
    this.source = source;
    this.content = content;
  }
  originalPositionFor(line, column, name) {
    return { column, line, name, source: this.source, content: this.content };
  }
};
var put;
var FastStringArray = class {
  constructor() {
    this.indexes = /* @__PURE__ */ Object.create(null);
    this.array = [];
  }
};
(() => {
  put = (strarr, key) => {
    const { array, indexes } = strarr;
    let index = indexes[key];
    if (index === void 0) {
      index = indexes[key] = array.length;
      array.push(key);
    }
    return index;
  };
})();
var INVALID_MAPPING2 = void 0;
var SOURCELESS_MAPPING = null;
var traceMappings;
var SourceMapTree = class {
  constructor(map, sources) {
    this.map = map;
    this.sources = sources;
  }
  originalPositionFor(line, column, name) {
    const segment = traceSegment(this.map, line, column);
    if (segment == null)
      return INVALID_MAPPING2;
    if (segment.length === 1)
      return SOURCELESS_MAPPING;
    const source = this.sources[segment[1]];
    return source.originalPositionFor(segment[2], segment[3], segment.length === 5 ? this.map.names[segment[4]] : name);
  }
};
(() => {
  traceMappings = (tree) => {
    const mappings = [];
    const names = new FastStringArray();
    const sources = new FastStringArray();
    const sourcesContent = [];
    const { sources: rootSources, map } = tree;
    const rootNames = map.names;
    const rootMappings = decodedMappings(map);
    let lastLineWithSegment = -1;
    for (let i = 0; i < rootMappings.length; i++) {
      const segments = rootMappings[i];
      const tracedSegments = [];
      let lastSourcesIndex = -1;
      let lastSourceLine = -1;
      let lastSourceColumn = -1;
      for (let j = 0; j < segments.length; j++) {
        const segment = segments[j];
        let traced = SOURCELESS_MAPPING;
        if (segment.length !== 1) {
          const source2 = rootSources[segment[1]];
          traced = source2.originalPositionFor(segment[2], segment[3], segment.length === 5 ? rootNames[segment[4]] : "");
          if (traced === INVALID_MAPPING2)
            continue;
        }
        const genCol = segment[0];
        if (traced === SOURCELESS_MAPPING) {
          if (lastSourcesIndex === -1) {
            continue;
          }
          lastSourcesIndex = lastSourceLine = lastSourceColumn = -1;
          tracedSegments.push([genCol]);
          continue;
        }
        const { column, line, name, content, source } = traced;
        const sourcesIndex = put(sources, source);
        sourcesContent[sourcesIndex] = content;
        if (lastSourcesIndex === sourcesIndex && lastSourceLine === line && lastSourceColumn === column) {
          continue;
        }
        lastLineWithSegment = i;
        lastSourcesIndex = sourcesIndex;
        lastSourceLine = line;
        lastSourceColumn = column;
        tracedSegments.push(name ? [genCol, sourcesIndex, line, column, put(names, name)] : [genCol, sourcesIndex, line, column]);
      }
      mappings.push(tracedSegments);
    }
    if (mappings.length > lastLineWithSegment + 1) {
      mappings.length = lastLineWithSegment + 1;
    }
    return presortedDecodedMap(Object.assign({}, tree.map, {
      mappings,
      sourceRoot: void 0,
      names: names.array,
      sources: sources.array,
      sourcesContent
    }));
  };
})();
function asArray(value) {
  if (Array.isArray(value))
    return value;
  return [value];
}
function buildSourceMapTree(input, loader) {
  const maps = asArray(input).map((m) => new TraceMap(m, ""));
  const map = maps.pop();
  for (let i = 0; i < maps.length; i++) {
    if (maps[i].sources.length > 1) {
      throw new Error(`Transformation map ${i} must have exactly one source file.
Did you specify these with the most recent transformation maps first?`);
    }
  }
  let tree = build(map, loader, "", 0);
  for (let i = maps.length - 1; i >= 0; i--) {
    tree = new SourceMapTree(maps[i], [tree]);
  }
  return tree;
}
function build(map, loader, importer, importerDepth) {
  const { resolvedSources, sourcesContent } = map;
  const depth = importerDepth + 1;
  const children = resolvedSources.map((sourceFile, i) => {
    const ctx = {
      importer,
      depth,
      source: sourceFile || "",
      content: void 0
    };
    const sourceMap = loader(ctx.source, ctx);
    const { source, content } = ctx;
    if (!sourceMap) {
      const sourceContent = content !== void 0 ? content : sourcesContent ? sourcesContent[i] : null;
      return new OriginalSource(source, sourceContent);
    }
    return build(new TraceMap(sourceMap, source), loader, source, depth);
  });
  return new SourceMapTree(map, children);
}
var SourceMap = class {
  constructor(map, options) {
    this.version = 3;
    this.file = map.file;
    this.mappings = options.decodedMappings ? decodedMappings(map) : encodedMappings(map);
    this.names = map.names;
    this.sourceRoot = map.sourceRoot;
    this.sources = map.sources;
    if (!options.excludeContent && "sourcesContent" in map) {
      this.sourcesContent = map.sourcesContent;
    }
  }
  toString() {
    return JSON.stringify(this);
  }
};
function remapping(input, loader, options) {
  const opts = typeof options === "object" ? options : { excludeContent: !!options, decodedMappings: false };
  const tree = buildSourceMapTree(input, loader);
  return new SourceMap(traceMappings(tree), opts);
}

// src/esbuild/utils.ts
var ExtToLoader = {
  ".js": "js",
  ".mjs": "js",
  ".cjs": "js",
  ".jsx": "jsx",
  ".ts": "ts",
  ".cts": "ts",
  ".mts": "ts",
  ".tsx": "tsx",
  ".css": "css",
  ".less": "css",
  ".stylus": "css",
  ".scss": "css",
  ".sass": "css",
  ".json": "json",
  ".txt": "text"
};
function guessLoader(id) {
  return ExtToLoader[(0, import_path.extname)(id).toLowerCase()] || "js";
}
function fixSourceMap(map) {
  if (!("toString" in map)) {
    Object.defineProperty(map, "toString", {
      enumerable: false,
      value: function toString() {
        return JSON.stringify(this);
      }
    });
  }
  if (!("toUrl" in map)) {
    Object.defineProperty(map, "toUrl", {
      enumerable: false,
      value: function toUrl() {
        return "data:application/json;charset=utf-8;base64," + Buffer.from(this.toString()).toString("base64");
      }
    });
  }
  return map;
}
var nullSourceMap = {
  names: [],
  sources: [],
  mappings: "",
  version: 3
};
function combineSourcemaps(filename, sourcemapList) {
  sourcemapList = sourcemapList.filter((m) => m.sources);
  if (sourcemapList.length === 0 || sourcemapList.every((m) => m.sources.length === 0)) {
    return __spreadValues({}, nullSourceMap);
  }
  let map;
  let mapIndex = 1;
  const useArrayInterface = sourcemapList.slice(0, -1).find((m) => m.sources.length !== 1) === void 0;
  if (useArrayInterface) {
    map = remapping(sourcemapList, () => null, true);
  } else {
    map = remapping(sourcemapList[0], function loader(sourcefile) {
      if (sourcefile === filename && sourcemapList[mapIndex]) {
        return sourcemapList[mapIndex++];
      } else {
        return __spreadValues({}, nullSourceMap);
      }
    }, true);
  }
  if (!map.file) {
    delete map.file;
  }
  return map;
}

// src/esbuild/index.ts
var watchListRecord = {};
var watchList = /* @__PURE__ */ new Set();
function getEsbuildPlugin(factory) {
  return (userOptions) => {
    var _a, _b;
    const meta = {
      framework: "esbuild"
    };
    const plugin = factory(userOptions, meta);
    return {
      name: plugin.name,
      setup: (_b = (_a = plugin.esbuild) == null ? void 0 : _a.setup) != null ? _b : function setup({ onStart, onEnd, onResolve, onLoad, initialOptions, esbuild: { build: build2 } }) {
        var _a2, _b2, _c, _d;
        const onResolveFilter = (_b2 = (_a2 = plugin.esbuild) == null ? void 0 : _a2.onResolveFilter) != null ? _b2 : /.*/;
        const onLoadFilter = (_d = (_c = plugin.esbuild) == null ? void 0 : _c.onLoadFilter) != null ? _d : /.*/;
        if (plugin.buildStart) {
          onStart(() => plugin.buildStart.call({
            addWatchFile(id) {
              watchList.add(import_path2.default.resolve(id));
            },
            emitFile(emittedFile) {
              const outFileName = emittedFile.fileName || emittedFile.name;
              if (initialOptions.outdir && emittedFile.source && outFileName) {
                import_fs.default.writeFileSync(import_path2.default.resolve(initialOptions.outdir, outFileName), emittedFile.source);
              }
            },
            getWatchFiles() {
              return Array.from(watchList);
            }
          }));
        }
        if (plugin.buildEnd || initialOptions.watch) {
          const rebuild = () => build2(__spreadProps(__spreadValues({}, initialOptions), {
            watch: false
          }));
          onEnd(() => {
            var _a3;
            (_a3 = plugin.buildEnd) == null ? void 0 : _a3.call(plugin);
            if (initialOptions.watch) {
              Object.keys(watchListRecord).forEach((id) => {
                if (!watchList.has(id)) {
                  watchListRecord[id].close();
                  delete watchListRecord[id];
                }
              });
              watchList.forEach((id) => {
                if (!Object.keys(watchListRecord).includes(id)) {
                  watchListRecord[id] = import_chokidar.default.watch(id);
                  watchListRecord[id].on("change", () => {
                    var _a4;
                    (_a4 = plugin.watchChange) == null ? void 0 : _a4.call(plugin, id, { event: "update" });
                    rebuild();
                  });
                  watchListRecord[id].on("unlink", () => {
                    var _a4;
                    (_a4 = plugin.watchChange) == null ? void 0 : _a4.call(plugin, id, { event: "delete" });
                    rebuild();
                  });
                }
              });
            }
          });
        }
        if (plugin.resolveId) {
          onResolve({ filter: onResolveFilter }, async (args) => {
            const result = await plugin.resolveId(args.path, args.importer);
            if (typeof result === "string") {
              return { path: result, namespace: plugin.name };
            } else if (typeof result === "object" && result !== null) {
              return { path: result.id, external: result.external, namespace: plugin.name };
            }
          });
        }
        if (plugin.load || plugin.transform) {
          onLoad({ filter: onLoadFilter }, async (args) => {
            const errors = [];
            const warnings = [];
            const pluginContext = {
              error(message) {
                errors.push({ text: String(message) });
              },
              warn(message) {
                warnings.push({ text: String(message) });
              }
            };
            const resolveDir = import_path2.default.dirname(args.path);
            let code, map;
            if (plugin.load) {
              const result = await plugin.load.call(pluginContext, args.path);
              if (typeof result === "string") {
                code = result;
              } else if (typeof result === "object" && result !== null) {
                code = result.code;
                map = result.map;
              }
            }
            if (!plugin.transform) {
              if (code === void 0) {
                return null;
              }
              if (map) {
                if (!map.sourcesContent || map.sourcesContent.length === 0) {
                  map.sourcesContent = [code];
                }
                map = fixSourceMap(map);
                code += `
//# sourceMappingURL=${map.toUrl()}`;
              }
              return { contents: code, errors, warnings, loader: guessLoader(args.path), resolveDir };
            }
            if (!plugin.transformInclude || plugin.transformInclude(args.path)) {
              if (!code) {
                code = await import_fs.default.promises.readFile(args.path, "utf8");
              }
              const result = await plugin.transform.call(pluginContext, code, args.path);
              if (typeof result === "string") {
                code = result;
              } else if (typeof result === "object" && result !== null) {
                code = result.code;
                if (map && result.map) {
                  map = combineSourcemaps(args.path, [
                    result.map,
                    map
                  ]);
                } else {
                  map = result.map;
                }
              }
            }
            if (code) {
              if (map) {
                if (!map.sourcesContent || map.sourcesContent.length === 0) {
                  map.sourcesContent = [code];
                }
                map = fixSourceMap(map);
                code += `
//# sourceMappingURL=${map.toUrl()}`;
              }
              return { contents: code, errors, warnings, loader: guessLoader(args.path), resolveDir };
            }
          });
        }
      }
    };
  };
}

// src/rollup/index.ts
function getRollupPlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "rollup"
    };
    const rawPlugin = factory(userOptions, meta);
    return toRollupPlugin(rawPlugin);
  };
}
function toRollupPlugin(plugin) {
  if (plugin.transform && plugin.transformInclude) {
    const _transform = plugin.transform;
    plugin.transform = function(code, id) {
      if (plugin.transformInclude && !plugin.transformInclude(id)) {
        return null;
      }
      return _transform.call(this, code, id);
    };
  }
  if (plugin.rollup) {
    Object.assign(plugin, plugin.rollup);
  }
  return plugin;
}

// src/vite/index.ts
function getVitePlugin(factory) {
  return (userOptions) => {
    const meta = {
      framework: "vite"
    };
    const rawPlugin = factory(userOptions, meta);
    const plugin = toRollupPlugin(rawPlugin);
    if (rawPlugin.vite) {
      Object.assign(plugin, rawPlugin.vite);
    }
    return plugin;
  };
}

// src/webpack/index.ts
var import_fs2 = __toESM(require("fs"));
var import_url = require("url");
var import_path3 = require("path");
var import_webpack_virtual_modules = __toESM(require("webpack-virtual-modules"));

// src/webpack/utils.ts
function slash(path2) {
  return path2.replace(/\\/g, "/");
}
function backSlash(path2) {
  return path2.replace(/\//g, "\\");
}

// src/webpack/index.ts
var _dirname = typeof __dirname !== "undefined" ? __dirname : (0, import_path3.dirname)((0, import_url.fileURLToPath)(importMetaUrl));
var TRANSFORM_LOADER = (0, import_path3.resolve)(_dirname, "webpack/loaders/transform.js");
var LOAD_LOADER = (0, import_path3.resolve)(_dirname, "webpack/loaders/load.js");
function getWebpackPlugin(factory) {
  return (userOptions) => {
    return {
      apply(compiler) {
        const meta = {
          framework: "webpack",
          webpack: {
            compiler
          }
        };
        const virtualModulePrefix = (0, import_path3.resolve)(process.cwd(), "_virtual_");
        const rawPlugin = factory(userOptions, meta);
        const plugin = Object.assign(rawPlugin, {
          __unpluginMeta: meta,
          __virtualModulePrefix: virtualModulePrefix
        });
        const injected = compiler.$unpluginContext || {};
        compiler.$unpluginContext = injected;
        injected[plugin.name] = plugin;
        compiler.hooks.thisCompilation.tap(plugin.name, (compilation) => {
          compilation.hooks.childCompiler.tap(plugin.name, (childCompiler) => {
            childCompiler.$unpluginContext = injected;
          });
        });
        if (plugin.transform) {
          compiler.options.module.rules.push({
            include(id) {
              if (id == null) {
                return false;
              }
              if (plugin.transformInclude) {
                return plugin.transformInclude(id);
              } else {
                return true;
              }
            },
            enforce: plugin.enforce,
            use: [{
              loader: TRANSFORM_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.resolveId) {
          let vfs = compiler.options.plugins.find((i) => i instanceof import_webpack_virtual_modules.default);
          if (!vfs) {
            vfs = new import_webpack_virtual_modules.default();
            compiler.options.plugins.push(vfs);
          }
          plugin.__vfsModules = /* @__PURE__ */ new Set();
          plugin.__vfs = vfs;
          const resolver = {
            apply(resolver2) {
              const target = resolver2.ensureHook("resolve");
              const tap = () => async (request, resolveContext, callback) => {
                if (!request.request) {
                  return callback();
                }
                const id = backSlash(request.request);
                if (id.startsWith(plugin.__virtualModulePrefix)) {
                  return callback();
                }
                const result = await plugin.resolveId(slash(id));
                if (result == null) {
                  return callback();
                }
                let resolved = typeof result === "string" ? result : result.id;
                if (!import_fs2.default.existsSync(resolved)) {
                  resolved = plugin.__virtualModulePrefix + id;
                  plugin.__vfs.writeModule(resolved, "");
                  plugin.__vfsModules.add(resolved);
                }
                const newRequest = __spreadProps(__spreadValues({}, request), {
                  request: resolved
                });
                resolver2.doResolve(target, newRequest, null, resolveContext, callback);
              };
              resolver2.getHook("resolve").tapAsync("unplugin", tap());
            }
          };
          compiler.options.resolve.plugins = compiler.options.resolve.plugins || [];
          compiler.options.resolve.plugins.push(resolver);
        }
        if (plugin.load && plugin.__vfsModules) {
          compiler.options.module.rules.push({
            include(id) {
              return id != null && plugin.__vfsModules.has(id);
            },
            enforce: plugin.enforce,
            use: [{
              loader: LOAD_LOADER,
              options: {
                unpluginName: plugin.name
              }
            }]
          });
        }
        if (plugin.webpack) {
          plugin.webpack(compiler);
        }
        compiler.hooks.thisCompilation.tap(plugin.name, (compilation) => {
          var _a;
          (_a = plugin.buildStart) == null ? void 0 : _a.call({
            addWatchFile(id) {
              var _a2;
              ((_a2 = compilation.fileDependencies) != null ? _a2 : compilation.compilationDependencies).add((0, import_path3.resolve)(process.cwd(), id));
            },
            emitFile(emittedFile) {
              var _a2;
              const outFileName = emittedFile.fileName || emittedFile.name;
              if (emittedFile.source && outFileName) {
                compilation.emitAsset(outFileName, ((_a2 = compiler.webpack) == null ? void 0 : _a2.sources) ? new compiler.webpack.sources.RawSource(typeof emittedFile.source === "string" ? emittedFile.source : Buffer.from(emittedFile.source)) : {
                  source: () => emittedFile.source,
                  size: () => emittedFile.source.length
                });
              }
            },
            getWatchFiles() {
              var _a2;
              return Array.from((_a2 = compilation.fileDependencies) != null ? _a2 : compilation.compilationDependencies);
            }
          });
        });
        if (plugin.watchChange) {
          compiler.hooks.watchRun.tap(plugin.name, (compilation) => {
            if (compilation.modifiedFiles) {
              compilation.modifiedFiles.forEach((file) => plugin.watchChange(file, { event: "update" }));
            }
            if (compilation.removedFiles) {
              compilation.removedFiles.forEach((file) => plugin.watchChange(file, { event: "delete" }));
            }
          });
        }
        if (plugin.buildEnd) {
          compiler.hooks.done.tapPromise(plugin.name, async () => {
            await plugin.buildEnd();
          });
        }
      }
    };
  };
}

// src/define.ts
function createUnplugin(factory) {
  return {
    get esbuild() {
      return getEsbuildPlugin(factory);
    },
    get rollup() {
      return getRollupPlugin(factory);
    },
    get vite() {
      return getVitePlugin(factory);
    },
    get webpack() {
      return getWebpackPlugin(factory);
    },
    get raw() {
      return factory;
    }
  };
}
module.exports = __toCommonJS(src_exports);
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createUnplugin
});
