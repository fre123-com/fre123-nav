import { join, relative, resolve, dirname, isAbsolute } from 'pathe';
import { watch } from 'chokidar';
import { useNuxt, tryResolveModule, createResolver, addTemplate, findPath, resolveAlias, useLogger, isNuxt3, addDevServerHandler, isNuxt2, defineNuxtModule, resolvePath, getNuxtVersion, installModule, addImportsDir, addVitePlugin } from '@nuxt/kit';
import defaultTailwindConfig from 'tailwindcss/stubs/config.simple.js';
import resolveConfig from 'tailwindcss/resolveConfig.js';
import loadConfig from 'tailwindcss/loadConfig.js';
import { createDefu as createDefu$1, defu as defu$1 } from 'defu';
import { existsSync } from 'fs';
import micromatch from 'micromatch';
import { underline, yellow } from 'colorette';
import { eventHandler, sendRedirect } from 'h3';
import { joinURL, withoutTrailingSlash, cleanDoubleSlashes, withTrailingSlash } from 'ufo';

const NON_ALPHANUMERIC_RE = /^[0-9a-z]+$/i;
const isJSObject = (value) => typeof value === "object" && !Array.isArray(value);
const configMerger = createDefu$1((obj, key, value) => {
  if (key === "content") {
    if (isJSObject(obj[key]) && Array.isArray(value)) {
      obj[key]["files"] = [...obj[key]["files"] || [], ...value];
      return true;
    } else if (Array.isArray(obj[key]) && isJSObject(value)) {
      obj[key] = { ...value, files: [...obj[key], ...value.files || []] };
      return true;
    }
  }
  if (Array.isArray(obj[key]) && typeof value === "function") {
    obj[key] = value(obj[key]);
    return true;
  }
});

const resolveConfigPath = async (path) => (await Promise.all(
  (Array.isArray(path) ? path : [path]).filter(Boolean).map((path2) => findPath(path2, { extensions: [".js", ".cjs", ".mjs", ".ts"] }))
)).filter((i) => Boolean(i));
const resolveContentPaths = (srcDir, nuxt = useNuxt()) => {
  const r = (p) => p.startsWith(srcDir) ? p : resolve(srcDir, p);
  const extensionFormat = (s) => s.length > 1 ? `.{${s.join(",")}}` : `.${s.join("") || "vue"}`;
  const defaultExtensions = extensionFormat(["js", "ts", "mjs"]);
  const extensions = Array.from(/* @__PURE__ */ new Set(["vue", ...nuxt.options.extensions]));
  const sfcExtensions = extensionFormat(extensions.map((e) => e.replace(/^\.*/, "")));
  const importDirs = [...nuxt.options.imports?.dirs || []].map(r);
  const [composablesDir, utilsDir] = [resolve(srcDir, "composables"), resolve(srcDir, "utils")];
  if (!importDirs.includes(composablesDir))
    importDirs.push(composablesDir);
  if (!importDirs.includes(utilsDir))
    importDirs.push(utilsDir);
  return [
    r(`components/**/*${sfcExtensions}`),
    ...(() => {
      if (nuxt.options.components) {
        return (Array.isArray(nuxt.options.components) ? nuxt.options.components : typeof nuxt.options.components === "boolean" ? ["components"] : nuxt.options.components.dirs).map((d) => `${resolveAlias(typeof d === "string" ? d : d.path)}/**/*${sfcExtensions}`);
      }
      return [];
    })(),
    r(`${nuxt.options.dir.layouts}/**/*${sfcExtensions}`),
    ...[true, void 0].includes(nuxt.options.pages) ? [r(`${nuxt.options.dir.pages}/**/*${sfcExtensions}`)] : [],
    r(`${nuxt.options.dir.plugins}/**/*${defaultExtensions}`),
    ...importDirs.map((d) => `${d}/**/*${defaultExtensions}`),
    r(`{A,a}pp${sfcExtensions}`),
    r(`{E,e}rror${sfcExtensions}`),
    r(`app.config${defaultExtensions}`)
  ];
};
const resolveModulePaths = async (configPath, nuxt = useNuxt()) => nuxt.options._layers && nuxt.options._layers.length > 1 ? (await Promise.all(
  // nuxt.options._layers is from rootDir to nested level
  // We need to reverse the order to give the deepest tailwind.config the lowest priority
  nuxt.options._layers.slice().reverse().map(async (layer) => [
    await resolveConfigPath(layer?.config?.tailwindcss?.configPath || join(layer.cwd, "tailwind.config")),
    resolveContentPaths(layer?.config?.srcDir || layer.cwd)
  ])
)).reduce((prev, curr) => prev.map((p, i) => p.concat(curr[i]))) : [await resolveConfigPath(configPath), resolveContentPaths(nuxt.options.srcDir)];
async function resolveCSSPath(cssPath, nuxt = useNuxt()) {
  if (typeof cssPath === "string") {
    return existsSync(cssPath) ? [cssPath, `Using Tailwind CSS from ~/${relative(nuxt.options.srcDir, cssPath)}`] : await tryResolveModule("tailwindcss/package.json").then((twLocation) => twLocation ? [join(twLocation, "../tailwind.css"), "Using default Tailwind CSS file"] : Promise.reject("tailwindcss not resolved")).catch((e) => [
      createResolver(import.meta.url).resolve(
        addTemplate({
          filename: "_tailwind.css",
          write: true,
          getContents: () => "@tailwind base;\n@tailwind components;\n@tailwind utilities;"
        }).dst
      ),
      `Faced error while trying to use default Tailwind CSS file: ${e?.name || ""} ${e?.message || e}
Created default Tailwind CSS file`
    ]);
  } else {
    return [
      createResolver(import.meta.url).resolve(
        addTemplate({
          filename: "tailwind-empty.css",
          write: true,
          getContents: () => ""
        }).dst
      ),
      "No Tailwind CSS file found. Skipping..."
    ];
  }
}
const resolveBoolObj = (config, fb) => defu$1(typeof config === "object" ? config : {}, fb);
const resolveViewerConfig = (config) => resolveBoolObj(config, { endpoint: "/_tailwind", exportViewer: false });
const resolveExposeConfig = (config) => resolveBoolObj(config, { alias: "#tailwind-config", level: 2 });
function resolveInjectPosition(css, position) {
  if (typeof position === "number") {
    return ~~Math.min(position, css.length + 1);
  }
  if (typeof position === "string") {
    switch (position) {
      case "first":
        return 0;
      case "last":
        return css.length;
      default:
        throw new Error("invalid literal: " + position);
    }
  }
  if (position.after !== void 0) {
    const index = css.indexOf(position.after);
    if (index === -1) {
      throw new Error("`after` position specifies a file which does not exists on CSS stack: " + position.after);
    }
    return index + 1;
  }
  throw new Error("invalid position: " + JSON.stringify(position));
}

const LogLevels = {
  silent: Number.NEGATIVE_INFINITY,
  fatal: 0,
  error: 0,
  warn: 1,
  log: 2,
  info: 3,
  success: 3,
  fail: 3,
  ready: 3,
  start: 3,
  box: 3,
  debug: 4,
  trace: 5,
  verbose: Number.POSITIVE_INFINITY
};
const LogTypes = {
  // Silent
  silent: {
    level: -1
  },
  // Level 0
  fatal: {
    level: LogLevels.fatal
  },
  error: {
    level: LogLevels.error
  },
  // Level 1
  warn: {
    level: LogLevels.warn
  },
  // Level 2
  log: {
    level: LogLevels.log
  },
  // Level 3
  info: {
    level: LogLevels.info
  },
  success: {
    level: LogLevels.success
  },
  fail: {
    level: LogLevels.fail
  },
  ready: {
    level: LogLevels.info
  },
  start: {
    level: LogLevels.info
  },
  box: {
    level: LogLevels.info
  },
  // Level 4
  debug: {
    level: LogLevels.debug
  },
  // Level 5
  trace: {
    level: LogLevels.trace
  },
  // Verbose
  verbose: {
    level: LogLevels.verbose
  }
};

function isObject(value) {
  return value !== null && typeof value === "object";
}
function _defu(baseObject, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObject, {}, namespace, merger);
  }
  const object = Object.assign({}, defaults);
  for (const key in baseObject) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const value = baseObject[key];
    if (value === null || value === void 0) {
      continue;
    }
    if (merger && merger(object, key, value, namespace)) {
      continue;
    }
    if (Array.isArray(value) && Array.isArray(object[key])) {
      object[key] = [...value, ...object[key]];
    } else if (isObject(value) && isObject(object[key])) {
      object[key] = _defu(
        value,
        object[key],
        (namespace ? `${namespace}.` : "") + key.toString(),
        merger
      );
    } else {
      object[key] = value;
    }
  }
  return object;
}
function createDefu(merger) {
  return (...arguments_) => (
    // eslint-disable-next-line unicorn/no-array-reduce
    arguments_.reduce((p, c) => _defu(p, c, "", merger), {})
  );
}
const defu = createDefu();

function isPlainObject(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function isLogObj(arg) {
  if (!isPlainObject(arg)) {
    return false;
  }
  if (!arg.message && !arg.args) {
    return false;
  }
  if (arg.stack) {
    return false;
  }
  return true;
}

let paused = false;
const queue = [];
class Consola {
  constructor(options = {}) {
    const types = options.types || LogTypes;
    this.options = defu(
      {
        ...options,
        defaults: { ...options.defaults },
        level: _normalizeLogLevel(options.level, types),
        reporters: [...options.reporters || []]
      },
      {
        types: LogTypes,
        throttle: 1e3,
        throttleMin: 5,
        formatOptions: {
          date: true,
          colors: false,
          compact: true
        }
      }
    );
    for (const type in types) {
      const defaults = {
        type,
        ...this.options.defaults,
        ...types[type]
      };
      this[type] = this._wrapLogFn(defaults);
      this[type].raw = this._wrapLogFn(
        defaults,
        true
      );
    }
    if (this.options.mockFn) {
      this.mockTypes();
    }
    this._lastLog = {};
  }
  get level() {
    return this.options.level;
  }
  set level(level) {
    this.options.level = _normalizeLogLevel(
      level,
      this.options.types,
      this.options.level
    );
  }
  prompt(message, opts) {
    if (!this.options.prompt) {
      throw new Error("prompt is not supported!");
    }
    return this.options.prompt(message, opts);
  }
  create(options) {
    const instance = new Consola({
      ...this.options,
      ...options
    });
    if (this._mockFn) {
      instance.mockTypes(this._mockFn);
    }
    return instance;
  }
  withDefaults(defaults) {
    return this.create({
      ...this.options,
      defaults: {
        ...this.options.defaults,
        ...defaults
      }
    });
  }
  withTag(tag) {
    return this.withDefaults({
      tag: this.options.defaults.tag ? this.options.defaults.tag + ":" + tag : tag
    });
  }
  addReporter(reporter) {
    this.options.reporters.push(reporter);
    return this;
  }
  removeReporter(reporter) {
    if (reporter) {
      const i = this.options.reporters.indexOf(reporter);
      if (i >= 0) {
        return this.options.reporters.splice(i, 1);
      }
    } else {
      this.options.reporters.splice(0);
    }
    return this;
  }
  setReporters(reporters) {
    this.options.reporters = Array.isArray(reporters) ? reporters : [reporters];
    return this;
  }
  wrapAll() {
    this.wrapConsole();
    this.wrapStd();
  }
  restoreAll() {
    this.restoreConsole();
    this.restoreStd();
  }
  wrapConsole() {
    for (const type in this.options.types) {
      if (!console["__" + type]) {
        console["__" + type] = console[type];
      }
      console[type] = this[type].raw;
    }
  }
  restoreConsole() {
    for (const type in this.options.types) {
      if (console["__" + type]) {
        console[type] = console["__" + type];
        delete console["__" + type];
      }
    }
  }
  wrapStd() {
    this._wrapStream(this.options.stdout, "log");
    this._wrapStream(this.options.stderr, "log");
  }
  _wrapStream(stream, type) {
    if (!stream) {
      return;
    }
    if (!stream.__write) {
      stream.__write = stream.write;
    }
    stream.write = (data) => {
      this[type].raw(String(data).trim());
    };
  }
  restoreStd() {
    this._restoreStream(this.options.stdout);
    this._restoreStream(this.options.stderr);
  }
  _restoreStream(stream) {
    if (!stream) {
      return;
    }
    if (stream.__write) {
      stream.write = stream.__write;
      delete stream.__write;
    }
  }
  pauseLogs() {
    paused = true;
  }
  resumeLogs() {
    paused = false;
    const _queue = queue.splice(0);
    for (const item of _queue) {
      item[0]._logFn(item[1], item[2]);
    }
  }
  mockTypes(mockFn) {
    const _mockFn = mockFn || this.options.mockFn;
    this._mockFn = _mockFn;
    if (typeof _mockFn !== "function") {
      return;
    }
    for (const type in this.options.types) {
      this[type] = _mockFn(type, this.options.types[type]) || this[type];
      this[type].raw = this[type];
    }
  }
  _wrapLogFn(defaults, isRaw) {
    return (...args) => {
      if (paused) {
        queue.push([this, defaults, args, isRaw]);
        return;
      }
      return this._logFn(defaults, args, isRaw);
    };
  }
  _logFn(defaults, args, isRaw) {
    if ((defaults.level || 0) > this.level) {
      return false;
    }
    const logObj = {
      date: /* @__PURE__ */ new Date(),
      args: [],
      ...defaults,
      level: _normalizeLogLevel(defaults.level, this.options.types)
    };
    if (!isRaw && args.length === 1 && isLogObj(args[0])) {
      Object.assign(logObj, args[0]);
    } else {
      logObj.args = [...args];
    }
    if (logObj.message) {
      logObj.args.unshift(logObj.message);
      delete logObj.message;
    }
    if (logObj.additional) {
      if (!Array.isArray(logObj.additional)) {
        logObj.additional = logObj.additional.split("\n");
      }
      logObj.args.push("\n" + logObj.additional.join("\n"));
      delete logObj.additional;
    }
    logObj.type = typeof logObj.type === "string" ? logObj.type.toLowerCase() : "log";
    logObj.tag = typeof logObj.tag === "string" ? logObj.tag : "";
    const resolveLog = (newLog = false) => {
      const repeated = (this._lastLog.count || 0) - this.options.throttleMin;
      if (this._lastLog.object && repeated > 0) {
        const args2 = [...this._lastLog.object.args];
        if (repeated > 1) {
          args2.push(`(repeated ${repeated} times)`);
        }
        this._log({ ...this._lastLog.object, args: args2 });
        this._lastLog.count = 1;
      }
      if (newLog) {
        this._lastLog.object = logObj;
        this._log(logObj);
      }
    };
    clearTimeout(this._lastLog.timeout);
    const diffTime = this._lastLog.time && logObj.date ? logObj.date.getTime() - this._lastLog.time.getTime() : 0;
    this._lastLog.time = logObj.date;
    if (diffTime < this.options.throttle) {
      try {
        const serializedLog = JSON.stringify([
          logObj.type,
          logObj.tag,
          logObj.args
        ]);
        const isSameLog = this._lastLog.serialized === serializedLog;
        this._lastLog.serialized = serializedLog;
        if (isSameLog) {
          this._lastLog.count = (this._lastLog.count || 0) + 1;
          if (this._lastLog.count > this.options.throttleMin) {
            this._lastLog.timeout = setTimeout(
              resolveLog,
              this.options.throttle
            );
            return;
          }
        }
      } catch {
      }
    }
    resolveLog(true);
  }
  _log(logObj) {
    for (const reporter of this.options.reporters) {
      reporter.log(logObj, {
        options: this.options
      });
    }
  }
}
function _normalizeLogLevel(input, types = {}, defaultLevel = 3) {
  if (input === void 0) {
    return defaultLevel;
  }
  if (typeof input === "number") {
    return input;
  }
  if (types[input] && types[input].level !== void 0) {
    return types[input].level;
  }
  return defaultLevel;
}
Consola.prototype.add = Consola.prototype.addReporter;
Consola.prototype.remove = Consola.prototype.removeReporter;
Consola.prototype.clear = Consola.prototype.removeReporter;
Consola.prototype.withScope = Consola.prototype.withTag;
Consola.prototype.mock = Consola.prototype.mockTypes;
Consola.prototype.pause = Consola.prototype.pauseLogs;
Consola.prototype.resume = Consola.prototype.resumeLogs;
function createConsola$1(options = {}) {
  return new Consola(options);
}

class BrowserReporter {
  constructor(options) {
    this.options = { ...options };
    this.defaultColor = "#7f8c8d";
    this.levelColorMap = {
      0: "#c0392b",
      // Red
      1: "#f39c12",
      // Yellow
      3: "#00BCD4"
      // Cyan
    };
    this.typeColorMap = {
      success: "#2ecc71"
      // Green
    };
  }
  _getLogFn(level) {
    if (level < 1) {
      return console.__error || console.error;
    }
    if (level === 1) {
      return console.__warn || console.warn;
    }
    return console.__log || console.log;
  }
  log(logObj) {
    const consoleLogFn = this._getLogFn(logObj.level);
    const type = logObj.type === "log" ? "" : logObj.type;
    const tag = logObj.tag || "";
    const color = this.typeColorMap[logObj.type] || this.levelColorMap[logObj.level] || this.defaultColor;
    const style = `
      background: ${color};
      border-radius: 0.5em;
      color: white;
      font-weight: bold;
      padding: 2px 0.5em;
    `;
    const badge = `%c${[tag, type].filter(Boolean).join(":")}`;
    if (typeof logObj.args[0] === "string") {
      consoleLogFn(
        `${badge}%c ${logObj.args[0]}`,
        style,
        // Empty string as style resets to default console style
        "",
        ...logObj.args.slice(1)
      );
    } else {
      consoleLogFn(badge, style, ...logObj.args);
    }
  }
}

function createConsola(options = {}) {
  const consola2 = createConsola$1({
    reporters: options.reporters || [new BrowserReporter({})],
    prompt(message, options2 = {}) {
      if (options2.type === "confirm") {
        return Promise.resolve(confirm(message));
      }
      return Promise.resolve(prompt(message));
    },
    ...options
  });
  return consola2;
}
createConsola();

const logger = useLogger("nuxt:tailwindcss");

function createTemplates(resolvedConfig, config, nuxt = useNuxt()) {
  const dtsContent = [];
  const populateMap = (obj, path = [], level = 1) => {
    Object.entries(obj).forEach(([key, value = {}]) => {
      const subpath = path.concat(key).join("/");
      if (level >= config.level || // if recursive call is more than desired
      !isJSObject(value) || // if its not an object, no more recursion required
      Object.keys(value).find((k) => !k.match(NON_ALPHANUMERIC_RE))) {
        if (isJSObject(value)) {
          const [validKeys, invalidKeys] = [[], []];
          Object.keys(value).forEach((i) => (NON_ALPHANUMERIC_RE.test(i) ? validKeys : invalidKeys).push(i));
          addTemplate({
            filename: `tailwind.config/${subpath}.mjs`,
            getContents: () => `${validKeys.map((i) => `const _${i} = ${JSON.stringify(value[i])}`).join("\n")}
const config = { ${validKeys.map((i) => `"${i}": _${i}, `).join("")}${invalidKeys.map((i) => `"${i}": ${JSON.stringify(value[i])}, `).join("")} }
export { config as default${validKeys.length > 0 ? ", _" : ""}${validKeys.join(", _")} }`
          });
          dtsContent.push(`declare module "${config.alias}/${subpath}" { ${validKeys.map((i) => `export const _${i}: ${JSON.stringify(value[i])};`).join("")} const defaultExport: { ${validKeys.map((i) => `"${i}": typeof _${i}, `).join("")}${invalidKeys.map((i) => `"${i}": ${JSON.stringify(value[i])}, `).join("")} }; export default defaultExport; }`);
        } else {
          addTemplate({
            filename: `tailwind.config/${subpath}.mjs`,
            getContents: () => `export default ${JSON.stringify(value, null, 2)}`
          });
          dtsContent.push(`declare module "${config.alias}/${subpath}" { const defaultExport: ${JSON.stringify(value)}; export default defaultExport; }`);
        }
      } else {
        populateMap(value, path.concat(key), level + 1);
        const values = Object.keys(value);
        addTemplate({
          filename: `tailwind.config/${subpath}.mjs`,
          getContents: () => `${values.map((v) => `import _${v} from "./${key}/${v}.mjs"`).join("\n")}
const config = { ${values.map((k) => `"${k}": _${k}`).join(", ")} }
export { config as default${values.length > 0 ? ", _" : ""}${values.join(", _")} }`
        });
        dtsContent.push(`declare module "${config.alias}/${subpath}" {${Object.keys(value).map((v) => ` export const _${v}: typeof import("${config.alias}/${join(`${key}/${subpath}`, `../${v}`)}")["default"];`).join("")} const defaultExport: { ${values.map((k) => `"${k}": typeof _${k}`).join(", ")} }; export default defaultExport; }`);
      }
    });
  };
  populateMap(resolvedConfig);
  const configOptions = Object.keys(resolvedConfig);
  const template = addTemplate({
    filename: "tailwind.config/index.mjs",
    getContents: () => `${configOptions.map((v) => `import ${v} from "#build/tailwind.config/${v}.mjs"`).join("\n")}
const config = { ${configOptions.join(", ")} }
export { config as default, ${configOptions.join(", ")} }`,
    write: true
  });
  dtsContent.push(`declare module "${config.alias}" {${configOptions.map((v) => ` export const ${v}: typeof import("${join(config.alias, v)}")["default"];`).join("")} const defaultExport: { ${configOptions.map((v) => `"${v}": typeof ${v}`)} }; export default defaultExport; }`);
  const typesTemplate = addTemplate({
    filename: "tailwind.config.d.ts",
    getContents: () => dtsContent.join("\n"),
    write: true
  });
  nuxt.options.alias[config.alias] = dirname(template.dst);
  nuxt.hook("prepare:types", (opts) => {
    opts.references.push({ path: typesTemplate.dst });
  });
}

function vitePlugin(tailwindConfig = {}, rootDir, cssPath) {
  const resolvedContent = (Array.isArray(tailwindConfig.content) ? tailwindConfig.content : tailwindConfig.content?.files || []).filter((f) => typeof f === "string").map((f) => !isAbsolute(f) ? resolve(rootDir, f) : f);
  return {
    name: "nuxt:tailwindcss",
    handleHotUpdate(ctx) {
      if (resolvedContent.findIndex((c) => micromatch.isMatch(ctx.file, c)) === -1) {
        return;
      }
      const extraModules = ctx.server.moduleGraph.getModulesByFile(cssPath) || /* @__PURE__ */ new Set();
      const timestamp = +Date.now();
      for (const mod of extraModules) {
        ctx.server.moduleGraph.invalidateModule(mod, void 0, timestamp);
      }
      ctx.server.ws.send({
        type: "update",
        updates: Array.from(extraModules).map((mod) => {
          return {
            type: mod.type === "js" ? "js-update" : "css-update",
            path: mod.url,
            acceptedPath: mod.url,
            timestamp
          };
        })
      });
      if (ctx.file.includes("/content-cache/")) {
        return true;
      }
    }
  };
}

const setupViewer = async (twConfig, config, nuxt = useNuxt()) => {
  const route = joinURL(nuxt.options.app?.baseURL, config.endpoint);
  const createServer = await import('tailwind-config-viewer/server/index.js').then((r) => r.default || r);
  const routerPrefix = isNuxt3() ? route : void 0;
  const _viewerDevMiddleware = createServer({ tailwindConfigProvider: () => twConfig, routerPrefix }).asMiddleware();
  const viewerDevMiddleware = eventHandler((event) => {
    const withoutSlash = withoutTrailingSlash(route);
    if (event.node?.req.url === withoutSlash || event.req.url === withoutSlash) {
      return sendRedirect(event, route, 301);
    }
    _viewerDevMiddleware(event.node?.req || event.req, event.node?.res || event.res);
  });
  if (isNuxt3()) {
    addDevServerHandler({ route, handler: viewerDevMiddleware });
  }
  if (isNuxt2()) {
    nuxt.options.serverMiddleware.push({ route, handler: (req, res) => viewerDevMiddleware(new H3Event(req, res)) });
  }
  nuxt.hook("listen", (_, listener) => {
    const viewerUrl = `${cleanDoubleSlashes(joinURL(withoutTrailingSlash(listener.url), route))}`;
    logger.info(`Tailwind Viewer: ${underline(yellow(withTrailingSlash(viewerUrl)))}`);
  });
};
const exportViewer = async (pathToConfig, config, nuxt = useNuxt()) => {
  if (!config.exportViewer) {
    return;
  }
  const cli = await import('tailwind-config-viewer/cli/export.js').then((r) => r.default || r);
  nuxt.hook("nitro:build:public-assets", (nitro) => {
    const dir = joinURL(nitro.options.output.publicDir, config.endpoint);
    cli(dir, pathToConfig);
    logger.success(`Exported viewer to ${yellow(relative(nuxt.options.srcDir, dir))}`);
  });
};

const name = "@nuxtjs/tailwindcss";
const version = "6.10.1";
const configKey = "tailwindcss";
const compatibility = {
	nuxt: "^2.9.0 || ^3.0.0-rc.1"
};

const defaults = (nuxt = useNuxt()) => ({
  configPath: "tailwind.config",
  cssPath: join(nuxt.options.dir.assets, "css/tailwind.css"),
  config: defaultTailwindConfig,
  viewer: true,
  exposeConfig: false,
  exposeLevel: 2,
  injectPosition: "first",
  disableHmrHotfix: false,
  quiet: nuxt.options.logLevel === "silent",
  addTwUtil: false
});
const module = defineNuxtModule({
  meta: { name, version, configKey, compatibility },
  defaults,
  async setup(moduleOptions, nuxt) {
    if (moduleOptions.quiet)
      logger.level = LogLevels.silent;
    const { resolve } = createResolver(import.meta.url);
    const [configPaths, contentPaths] = await resolveModulePaths(moduleOptions.configPath, nuxt);
    const tailwindConfig = await Promise.all(
      configPaths.map(async (configPath, idx, paths) => {
        let _tailwindConfig;
        try {
          _tailwindConfig = loadConfig(configPath);
        } catch (e) {
          logger.warn(`Failed to load Tailwind config at: \`./${relative(nuxt.options.rootDir, configPath)}\``, e);
        }
        if (_tailwindConfig && !_tailwindConfig.content) {
          _tailwindConfig.content = _tailwindConfig.purge;
        }
        await nuxt.callHook("tailwindcss:loadConfig", _tailwindConfig, configPath, idx, paths);
        return _tailwindConfig || {};
      })
    ).then((configs) => configs.reduce(
      (prev, curr) => configMerger(curr, prev),
      // internal default tailwind config
      configMerger(moduleOptions.config, { content: contentPaths })
    ));
    await nuxt.callHook("tailwindcss:config", tailwindConfig);
    const resolvedConfig = resolveConfig(tailwindConfig);
    await nuxt.callHook("tailwindcss:resolvedConfig", resolvedConfig);
    if (moduleOptions.exposeConfig) {
      const exposeConfig = resolveExposeConfig({ level: moduleOptions.exposeLevel, ...typeof moduleOptions.exposeConfig === "object" ? moduleOptions.exposeConfig : {} });
      createTemplates(resolvedConfig, exposeConfig, nuxt);
      isNuxt2() && addTemplate({ filename: "tailwind.config.cjs", getContents: () => `module.exports = ${JSON.stringify(resolvedConfig, null, 2)}` });
    }
    tailwindConfig._hash = String(Date.now());
    const cssPath = typeof moduleOptions.cssPath === "string" ? await resolvePath(moduleOptions.cssPath, { extensions: [".css", ".sass", ".scss", ".less", ".styl"] }) : false;
    const [resolvedCss, loggerInfo] = await resolveCSSPath(cssPath, nuxt);
    logger.info(loggerInfo);
    nuxt.options.css = nuxt.options.css ?? [];
    const resolvedNuxtCss = await Promise.all(nuxt.options.css.map((p) => resolvePath(p.src ?? p)));
    if (!resolvedNuxtCss.includes(resolvedCss)) {
      let injectPosition;
      try {
        injectPosition = resolveInjectPosition(nuxt.options.css, moduleOptions.injectPosition);
      } catch (e) {
        throw new Error("failed to resolve Tailwind CSS injection position: " + e.message);
      }
      nuxt.options.css.splice(injectPosition, 0, resolvedCss);
    }
    const postcssOptions = nuxt.options.postcss || /* nuxt 3 */
    /* @ts-ignore */
    nuxt.options.build.postcss.postcssOptions || /* older nuxt3 */
    /* @ts-ignore */
    nuxt.options.build.postcss;
    postcssOptions.plugins = postcssOptions.plugins || {};
    postcssOptions.plugins["tailwindcss/nesting"] = postcssOptions.plugins["tailwindcss/nesting"] ?? {};
    postcssOptions.plugins["postcss-custom-properties"] = postcssOptions.plugins["postcss-custom-properties"] ?? {};
    postcssOptions.plugins.tailwindcss = tailwindConfig;
    if (parseFloat(getNuxtVersion()) < 2.16) {
      await installModule("@nuxt/postcss8").catch((e) => {
        logger.error(`Error occurred while loading \`@nuxt/postcss8\` required for Nuxt ${getNuxtVersion()}, is it installed?`);
        throw e;
      });
    }
    if (moduleOptions.addTwUtil) {
      addImportsDir(resolve("./runtime/utils"));
    }
    if (nuxt.options.dev) {
      if (isNuxt2()) {
        nuxt.options.watch = nuxt.options.watch || [];
        configPaths.forEach((path) => nuxt.options.watch.push(path));
      } else if (Array.isArray(nuxt.options.watch)) {
        configPaths.forEach((path) => nuxt.options.watch.push(relative(nuxt.options.srcDir, path)));
      } else {
        const watcher = watch(configPaths, { depth: 0 }).on("change", (path) => {
          logger.info(`Tailwind config changed: ${path}`);
          logger.warn("Please restart the Nuxt server to apply changes or upgrade to latest Nuxt for automatic restart.");
        });
        nuxt.hook("close", () => watcher.close());
      }
      if (!moduleOptions.disableHmrHotfix) {
        addVitePlugin(vitePlugin(tailwindConfig, nuxt.options.rootDir, resolvedCss));
      }
      if (moduleOptions.viewer) {
        const viewerConfig = resolveViewerConfig(moduleOptions.viewer);
        setupViewer(tailwindConfig, viewerConfig, nuxt);
        nuxt.hook("devtools:customTabs", (tabs) => {
          tabs.push({
            title: "TailwindCSS",
            name: "tailwindcss",
            icon: "logos-tailwindcss-icon",
            category: "modules",
            view: {
              type: "iframe",
              src: withTrailingSlash(viewerConfig.endpoint)
            }
          });
        });
      }
    } else {
      if (moduleOptions.viewer) {
        const configTemplate = addTemplate({ filename: "tw-viewer.config.cjs", getContents: () => `module.exports = ${JSON.stringify(tailwindConfig)}`, write: true });
        exportViewer(configTemplate.dst, resolveViewerConfig(moduleOptions.viewer));
      }
    }
  }
});

export { module as default };
