"use strict";var Li=Object.defineProperty;var u=(c,l)=>Li(c,"name",{value:l,configurable:!0});var co=(c,l,d)=>{if(!l.has(c))throw TypeError("Cannot "+d)};var L=(c,l,d)=>(co(c,l,"read from private field"),d?d.call(c):l.get(c)),ue=(c,l,d)=>{if(l.has(c))throw TypeError("Cannot add the same private member more than once");l instanceof WeakSet?l.add(c):l.set(c,d)},J=(c,l,d,b)=>(co(c,l,"write to private field"),b?b.call(c,d):l.set(c,d),d);var be,ct,et,Qt,Me,dt,ht,pt,X,bt,$e,De,mt;Object.defineProperty(exports,"__esModule",{value:!0});const http=require("node:http"),https=require("node:https"),zlib=require("node:zlib"),Stream=require("node:stream"),node_buffer=require("node:buffer"),require$$1=require("node:util"),_commonjsHelpers=require("./shared/node-fetch-native.61758d11.cjs"),node_url=require("node:url"),node_net=require("node:net"),node_fs=require("node:fs"),node_path=require("node:path");function _interopDefaultCompat(c){return c&&typeof c=="object"&&"default"in c?c.default:c}u(_interopDefaultCompat,"_interopDefaultCompat");const http__default=_interopDefaultCompat(http),https__default=_interopDefaultCompat(https),zlib__default=_interopDefaultCompat(zlib),Stream__default=_interopDefaultCompat(Stream);function dataUriToBuffer(c){if(!/^data:/i.test(c))throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');c=c.replace(/\r?\n/g,"");const l=c.indexOf(",");if(l===-1||l<=4)throw new TypeError("malformed data: URI");const d=c.substring(5,l).split(";");let b="",y=!1;const S=d[0]||"text/plain";let R=S;for(let N=1;N<d.length;N++)d[N]==="base64"?y=!0:d[N]&&(R+=`;${d[N]}`,d[N].indexOf("charset=")===0&&(b=d[N].substring(8)));!d[0]&&!b.length&&(R+=";charset=US-ASCII",b="US-ASCII");const C=y?"base64":"ascii",O=unescape(c.substring(l+1)),A=Buffer.from(O,C);return A.type=S,A.typeFull=R,A.charset=b,A}u(dataUriToBuffer,"dataUriToBuffer");var ponyfill_es2018={exports:{}},hasRequiredPonyfill_es2018;function requirePonyfill_es2018(){return hasRequiredPonyfill_es2018||(hasRequiredPonyfill_es2018=1,function(c,l){(function(d,b){b(l)})(_commonjsHelpers.commonjsGlobal,function(d){const b=typeof Symbol=="function"&&typeof Symbol.iterator=="symbol"?Symbol:n=>`Symbol(${n})`;function y(){}u(y,"noop");function S(){if(typeof self<"u")return self;if(typeof window<"u")return window;if(typeof _commonjsHelpers.commonjsGlobal<"u")return _commonjsHelpers.commonjsGlobal}u(S,"getGlobals");const R=S();function C(n){return typeof n=="object"&&n!==null||typeof n=="function"}u(C,"typeIsObject");const O=y,A=Promise,N=Promise.prototype.then,oe=Promise.resolve.bind(A),H=Promise.reject.bind(A);function F(n){return new A(n)}u(F,"newPromise");function T(n){return oe(n)}u(T,"promiseResolvedWith");function v(n){return H(n)}u(v,"promiseRejectedWith");function j(n,o,a){return N.call(n,o,a)}u(j,"PerformPromiseThen");function D(n,o,a){j(j(n,o,a),void 0,O)}u(D,"uponPromise");function ie(n,o){D(n,o)}u(ie,"uponFulfillment");function tt(n,o){D(n,void 0,o)}u(tt,"uponRejection");function $(n,o,a){return j(n,o,a)}u($,"transformPromiseWith");function V(n){j(n,void 0,O)}u(V,"setPromiseIsHandledToTrue");const U=(()=>{const n=R&&R.queueMicrotask;if(typeof n=="function")return n;const o=T(void 0);return a=>j(o,a)})();function Pe(n,o,a){if(typeof n!="function")throw new TypeError("Argument is not a function");return Function.prototype.apply.call(n,o,a)}u(Pe,"reflectCall");function le(n,o,a){try{return T(Pe(n,o,a))}catch(p){return v(p)}}u(le,"promiseCall");const Yr=16384,Ar=class Ar{constructor(){this._cursor=0,this._size=0,this._front={_elements:[],_next:void 0},this._back=this._front,this._cursor=0,this._size=0}get length(){return this._size}push(o){const a=this._back;let p=a;a._elements.length===Yr-1&&(p={_elements:[],_next:void 0}),a._elements.push(o),p!==a&&(this._back=p,a._next=p),++this._size}shift(){const o=this._front;let a=o;const p=this._cursor;let g=p+1;const _=o._elements,w=_[p];return g===Yr&&(a=o._next,g=0),--this._size,this._cursor=g,o!==a&&(this._front=a),_[p]=void 0,w}forEach(o){let a=this._cursor,p=this._front,g=p._elements;for(;(a!==g.length||p._next!==void 0)&&!(a===g.length&&(p=p._next,g=p._elements,a=0,g.length===0));)o(g[a]),++a}peek(){const o=this._front,a=this._cursor;return o._elements[a]}};u(Ar,"SimpleQueue");let Y=Ar;function Zr(n,o){n._ownerReadableStream=o,o._reader=n,o._state==="readable"?Jt(n):o._state==="closed"?ho(n):Kr(n,o._storedError)}u(Zr,"ReadableStreamReaderGenericInitialize");function Kt(n,o){const a=n._ownerReadableStream;return re(a,o)}u(Kt,"ReadableStreamReaderGenericCancel");function fe(n){n._ownerReadableStream._state==="readable"?Xt(n,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")):po(n,new TypeError("Reader was released and can no longer be used to monitor the stream's closedness")),n._ownerReadableStream._reader=void 0,n._ownerReadableStream=void 0}u(fe,"ReadableStreamReaderGenericRelease");function Ue(n){return new TypeError("Cannot "+n+" a stream using a released reader")}u(Ue,"readerLockException");function Jt(n){n._closedPromise=F((o,a)=>{n._closedPromise_resolve=o,n._closedPromise_reject=a})}u(Jt,"defaultReaderClosedPromiseInitialize");function Kr(n,o){Jt(n),Xt(n,o)}u(Kr,"defaultReaderClosedPromiseInitializeAsRejected");function ho(n){Jt(n),Jr(n)}u(ho,"defaultReaderClosedPromiseInitializeAsResolved");function Xt(n,o){n._closedPromise_reject!==void 0&&(V(n._closedPromise),n._closedPromise_reject(o),n._closedPromise_resolve=void 0,n._closedPromise_reject=void 0)}u(Xt,"defaultReaderClosedPromiseReject");function po(n,o){Kr(n,o)}u(po,"defaultReaderClosedPromiseResetToRejected");function Jr(n){n._closedPromise_resolve!==void 0&&(n._closedPromise_resolve(void 0),n._closedPromise_resolve=void 0,n._closedPromise_reject=void 0)}u(Jr,"defaultReaderClosedPromiseResolve");const Xr=b("[[AbortSteps]]"),en=b("[[ErrorSteps]]"),er=b("[[CancelSteps]]"),tr=b("[[PullSteps]]"),tn=Number.isFinite||function(n){return typeof n=="number"&&isFinite(n)},bo=Math.trunc||function(n){return n<0?Math.ceil(n):Math.floor(n)};function mo(n){return typeof n=="object"||typeof n=="function"}u(mo,"isDictionary");function ce(n,o){if(n!==void 0&&!mo(n))throw new TypeError(`${o} is not an object.`)}u(ce,"assertDictionary");function ee(n,o){if(typeof n!="function")throw new TypeError(`${o} is not a function.`)}u(ee,"assertFunction");function yo(n){return typeof n=="object"&&n!==null||typeof n=="function"}u(yo,"isObject");function rn(n,o){if(!yo(n))throw new TypeError(`${o} is not an object.`)}u(rn,"assertObject");function de(n,o,a){if(n===void 0)throw new TypeError(`Parameter ${o} is required in '${a}'.`)}u(de,"assertRequiredArgument");function rr(n,o,a){if(n===void 0)throw new TypeError(`${o} is required in '${a}'.`)}u(rr,"assertRequiredField");function nr(n){return Number(n)}u(nr,"convertUnrestrictedDouble");function nn(n){return n===0?0:n}u(nn,"censorNegativeZero");function go(n){return nn(bo(n))}u(go,"integerPart");function on(n,o){const p=Number.MAX_SAFE_INTEGER;let g=Number(n);if(g=nn(g),!tn(g))throw new TypeError(`${o} is not a finite number`);if(g=go(g),g<0||g>p)throw new TypeError(`${o} is outside the accepted range of 0 to ${p}, inclusive`);return!tn(g)||g===0?0:g}u(on,"convertUnsignedLongLongWithEnforceRange");function or(n,o){if(!Re(n))throw new TypeError(`${o} is not a ReadableStream.`)}u(or,"assertReadableStream");function xe(n){return new ve(n)}u(xe,"AcquireReadableStreamDefaultReader");function sn(n,o){n._reader._readRequests.push(o)}u(sn,"ReadableStreamAddReadRequest");function ir(n,o,a){const g=n._reader._readRequests.shift();a?g._closeSteps():g._chunkSteps(o)}u(ir,"ReadableStreamFulfillReadRequest");function yt(n){return n._reader._readRequests.length}u(yt,"ReadableStreamGetNumReadRequests");function an(n){const o=n._reader;return!(o===void 0||!me(o))}u(an,"ReadableStreamHasDefaultReader");const Br=class Br{constructor(o){if(de(o,1,"ReadableStreamDefaultReader"),or(o,"First parameter"),Te(o))throw new TypeError("This stream has already been locked for exclusive reading by another reader");Zr(this,o),this._readRequests=new Y}get closed(){return me(this)?this._closedPromise:v(gt("closed"))}cancel(o=void 0){return me(this)?this._ownerReadableStream===void 0?v(Ue("cancel")):Kt(this,o):v(gt("cancel"))}read(){if(!me(this))return v(gt("read"));if(this._ownerReadableStream===void 0)return v(Ue("read from"));let o,a;const p=F((_,w)=>{o=_,a=w});return rt(this,{_chunkSteps:_=>o({value:_,done:!1}),_closeSteps:()=>o({value:void 0,done:!0}),_errorSteps:_=>a(_)}),p}releaseLock(){if(!me(this))throw gt("releaseLock");if(this._ownerReadableStream!==void 0){if(this._readRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");fe(this)}}};u(Br,"ReadableStreamDefaultReader");let ve=Br;Object.defineProperties(ve.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(ve.prototype,b.toStringTag,{value:"ReadableStreamDefaultReader",configurable:!0});function me(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_readRequests")?!1:n instanceof ve}u(me,"IsReadableStreamDefaultReader");function rt(n,o){const a=n._ownerReadableStream;a._disturbed=!0,a._state==="closed"?o._closeSteps():a._state==="errored"?o._errorSteps(a._storedError):a._readableStreamController[tr](o)}u(rt,"ReadableStreamDefaultReaderRead");function gt(n){return new TypeError(`ReadableStreamDefaultReader.prototype.${n} can only be used on a ReadableStreamDefaultReader`)}u(gt,"defaultReaderBrandCheckException");const un=Object.getPrototypeOf(Object.getPrototypeOf(async function*(){}).prototype),Wr=class Wr{constructor(o,a){this._ongoingPromise=void 0,this._isFinished=!1,this._reader=o,this._preventCancel=a}next(){const o=u(()=>this._nextSteps(),"nextSteps");return this._ongoingPromise=this._ongoingPromise?$(this._ongoingPromise,o,o):o(),this._ongoingPromise}return(o){const a=u(()=>this._returnSteps(o),"returnSteps");return this._ongoingPromise?$(this._ongoingPromise,a,a):a()}_nextSteps(){if(this._isFinished)return Promise.resolve({value:void 0,done:!0});const o=this._reader;if(o._ownerReadableStream===void 0)return v(Ue("iterate"));let a,p;const g=F((w,P)=>{a=w,p=P});return rt(o,{_chunkSteps:w=>{this._ongoingPromise=void 0,U(()=>a({value:w,done:!1}))},_closeSteps:()=>{this._ongoingPromise=void 0,this._isFinished=!0,fe(o),a({value:void 0,done:!0})},_errorSteps:w=>{this._ongoingPromise=void 0,this._isFinished=!0,fe(o),p(w)}}),g}_returnSteps(o){if(this._isFinished)return Promise.resolve({value:o,done:!0});this._isFinished=!0;const a=this._reader;if(a._ownerReadableStream===void 0)return v(Ue("finish iterating"));if(!this._preventCancel){const p=Kt(a,o);return fe(a),$(p,()=>({value:o,done:!0}))}return fe(a),T({value:o,done:!0})}};u(Wr,"ReadableStreamAsyncIteratorImpl");let _t=Wr;const ln={next(){return fn(this)?this._asyncIteratorImpl.next():v(cn("next"))},return(n){return fn(this)?this._asyncIteratorImpl.return(n):v(cn("return"))}};un!==void 0&&Object.setPrototypeOf(ln,un);function _o(n,o){const a=xe(n),p=new _t(a,o),g=Object.create(ln);return g._asyncIteratorImpl=p,g}u(_o,"AcquireReadableStreamAsyncIterator");function fn(n){if(!C(n)||!Object.prototype.hasOwnProperty.call(n,"_asyncIteratorImpl"))return!1;try{return n._asyncIteratorImpl instanceof _t}catch{return!1}}u(fn,"IsReadableStreamAsyncIterator");function cn(n){return new TypeError(`ReadableStreamAsyncIterator.${n} can only be used on a ReadableSteamAsyncIterator`)}u(cn,"streamAsyncIteratorBrandCheckException");const dn=Number.isNaN||function(n){return n!==n};function nt(n){return n.slice()}u(nt,"CreateArrayFromList");function hn(n,o,a,p,g){new Uint8Array(n).set(new Uint8Array(a,p,g),o)}u(hn,"CopyDataBlockBytes");function $i(n){return n}u($i,"TransferArrayBuffer");function St(n){return!1}u(St,"IsDetachedBuffer");function pn(n,o,a){if(n.slice)return n.slice(o,a);const p=a-o,g=new ArrayBuffer(p);return hn(g,0,n,o,p),g}u(pn,"ArrayBufferSlice");function So(n){return!(typeof n!="number"||dn(n)||n<0)}u(So,"IsNonNegativeNumber");function bn(n){const o=pn(n.buffer,n.byteOffset,n.byteOffset+n.byteLength);return new Uint8Array(o)}u(bn,"CloneAsUint8Array");function sr(n){const o=n._queue.shift();return n._queueTotalSize-=o.size,n._queueTotalSize<0&&(n._queueTotalSize=0),o.value}u(sr,"DequeueValue");function ar(n,o,a){if(!So(a)||a===1/0)throw new RangeError("Size must be a finite, non-NaN, non-negative number.");n._queue.push({value:o,size:a}),n._queueTotalSize+=a}u(ar,"EnqueueValueWithSize");function wo(n){return n._queue.peek().value}u(wo,"PeekQueueValue");function ye(n){n._queue=new Y,n._queueTotalSize=0}u(ye,"ResetQueue");const kr=class kr{constructor(){throw new TypeError("Illegal constructor")}get view(){if(!ur(this))throw dr("view");return this._view}respond(o){if(!ur(this))throw dr("respond");if(de(o,1,"respond"),o=on(o,"First parameter"),this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");St(this._view.buffer),Pt(this._associatedReadableByteStreamController,o)}respondWithNewView(o){if(!ur(this))throw dr("respondWithNewView");if(de(o,1,"respondWithNewView"),!ArrayBuffer.isView(o))throw new TypeError("You can only respond with array buffer views");if(this._associatedReadableByteStreamController===void 0)throw new TypeError("This BYOB request has been invalidated");St(o.buffer),vt(this._associatedReadableByteStreamController,o)}};u(kr,"ReadableStreamBYOBRequest");let Ee=kr;Object.defineProperties(Ee.prototype,{respond:{enumerable:!0},respondWithNewView:{enumerable:!0},view:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ee.prototype,b.toStringTag,{value:"ReadableStreamBYOBRequest",configurable:!0});const Or=class Or{constructor(){throw new TypeError("Illegal constructor")}get byobRequest(){if(!Ae(this))throw it("byobRequest");return cr(this)}get desiredSize(){if(!Ae(this))throw it("desiredSize");return Tn(this)}close(){if(!Ae(this))throw it("close");if(this._closeRequested)throw new TypeError("The stream has already been closed; do not close it again!");const o=this._controlledReadableByteStream._state;if(o!=="readable")throw new TypeError(`The stream (in ${o} state) is not in the readable state and cannot be closed`);ot(this)}enqueue(o){if(!Ae(this))throw it("enqueue");if(de(o,1,"enqueue"),!ArrayBuffer.isView(o))throw new TypeError("chunk must be an array buffer view");if(o.byteLength===0)throw new TypeError("chunk must have non-zero byteLength");if(o.buffer.byteLength===0)throw new TypeError("chunk's buffer must have non-zero byteLength");if(this._closeRequested)throw new TypeError("stream is closed or draining");const a=this._controlledReadableByteStream._state;if(a!=="readable")throw new TypeError(`The stream (in ${a} state) is not in the readable state and cannot be enqueued to`);Ct(this,o)}error(o=void 0){if(!Ae(this))throw it("error");te(this,o)}[er](o){mn(this),ye(this);const a=this._cancelAlgorithm(o);return Tt(this),a}[tr](o){const a=this._controlledReadableByteStream;if(this._queueTotalSize>0){const g=this._queue.shift();this._queueTotalSize-=g.byteLength,Sn(this);const _=new Uint8Array(g.buffer,g.byteOffset,g.byteLength);o._chunkSteps(_);return}const p=this._autoAllocateChunkSize;if(p!==void 0){let g;try{g=new ArrayBuffer(p)}catch(w){o._errorSteps(w);return}const _={buffer:g,bufferByteLength:p,byteOffset:0,byteLength:p,bytesFilled:0,elementSize:1,viewConstructor:Uint8Array,readerType:"default"};this._pendingPullIntos.push(_)}sn(a,o),Be(this)}};u(Or,"ReadableByteStreamController");let ge=Or;Object.defineProperties(ge.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},byobRequest:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(ge.prototype,b.toStringTag,{value:"ReadableByteStreamController",configurable:!0});function Ae(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_controlledReadableByteStream")?!1:n instanceof ge}u(Ae,"IsReadableByteStreamController");function ur(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_associatedReadableByteStreamController")?!1:n instanceof Ee}u(ur,"IsReadableStreamBYOBRequest");function Be(n){if(!Po(n))return;if(n._pulling){n._pullAgain=!0;return}n._pulling=!0;const a=n._pullAlgorithm();D(a,()=>{n._pulling=!1,n._pullAgain&&(n._pullAgain=!1,Be(n))},p=>{te(n,p)})}u(Be,"ReadableByteStreamControllerCallPullIfNeeded");function mn(n){fr(n),n._pendingPullIntos=new Y}u(mn,"ReadableByteStreamControllerClearPendingPullIntos");function lr(n,o){let a=!1;n._state==="closed"&&(a=!0);const p=yn(o);o.readerType==="default"?ir(n,p,a):Ao(n,p,a)}u(lr,"ReadableByteStreamControllerCommitPullIntoDescriptor");function yn(n){const o=n.bytesFilled,a=n.elementSize;return new n.viewConstructor(n.buffer,n.byteOffset,o/a)}u(yn,"ReadableByteStreamControllerConvertPullIntoDescriptor");function wt(n,o,a,p){n._queue.push({buffer:o,byteOffset:a,byteLength:p}),n._queueTotalSize+=p}u(wt,"ReadableByteStreamControllerEnqueueChunkToQueue");function gn(n,o){const a=o.elementSize,p=o.bytesFilled-o.bytesFilled%a,g=Math.min(n._queueTotalSize,o.byteLength-o.bytesFilled),_=o.bytesFilled+g,w=_-_%a;let P=g,B=!1;w>p&&(P=w-o.bytesFilled,B=!0);const k=n._queue;for(;P>0;){const q=k.peek(),z=Math.min(P,q.byteLength),M=o.byteOffset+o.bytesFilled;hn(o.buffer,M,q.buffer,q.byteOffset,z),q.byteLength===z?k.shift():(q.byteOffset+=z,q.byteLength-=z),n._queueTotalSize-=z,_n(n,z,o),P-=z}return B}u(gn,"ReadableByteStreamControllerFillPullIntoDescriptorFromQueue");function _n(n,o,a){a.bytesFilled+=o}u(_n,"ReadableByteStreamControllerFillHeadPullIntoDescriptor");function Sn(n){n._queueTotalSize===0&&n._closeRequested?(Tt(n),ft(n._controlledReadableByteStream)):Be(n)}u(Sn,"ReadableByteStreamControllerHandleQueueDrain");function fr(n){n._byobRequest!==null&&(n._byobRequest._associatedReadableByteStreamController=void 0,n._byobRequest._view=null,n._byobRequest=null)}u(fr,"ReadableByteStreamControllerInvalidateBYOBRequest");function wn(n){for(;n._pendingPullIntos.length>0;){if(n._queueTotalSize===0)return;const o=n._pendingPullIntos.peek();gn(n,o)&&(Rt(n),lr(n._controlledReadableByteStream,o))}}u(wn,"ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue");function Ro(n,o,a){const p=n._controlledReadableByteStream;let g=1;o.constructor!==DataView&&(g=o.constructor.BYTES_PER_ELEMENT);const _=o.constructor,w=o.buffer,P={buffer:w,bufferByteLength:w.byteLength,byteOffset:o.byteOffset,byteLength:o.byteLength,bytesFilled:0,elementSize:g,viewConstructor:_,readerType:"byob"};if(n._pendingPullIntos.length>0){n._pendingPullIntos.push(P),vn(p,a);return}if(p._state==="closed"){const B=new _(P.buffer,P.byteOffset,0);a._closeSteps(B);return}if(n._queueTotalSize>0){if(gn(n,P)){const B=yn(P);Sn(n),a._chunkSteps(B);return}if(n._closeRequested){const B=new TypeError("Insufficient bytes to fill elements in the given buffer");te(n,B),a._errorSteps(B);return}}n._pendingPullIntos.push(P),vn(p,a),Be(n)}u(Ro,"ReadableByteStreamControllerPullInto");function To(n,o){const a=n._controlledReadableByteStream;if(hr(a))for(;En(a)>0;){const p=Rt(n);lr(a,p)}}u(To,"ReadableByteStreamControllerRespondInClosedState");function Co(n,o,a){if(_n(n,o,a),a.bytesFilled<a.elementSize)return;Rt(n);const p=a.bytesFilled%a.elementSize;if(p>0){const g=a.byteOffset+a.bytesFilled,_=pn(a.buffer,g-p,g);wt(n,_,0,_.byteLength)}a.bytesFilled-=p,lr(n._controlledReadableByteStream,a),wn(n)}u(Co,"ReadableByteStreamControllerRespondInReadableState");function Rn(n,o){const a=n._pendingPullIntos.peek();fr(n),n._controlledReadableByteStream._state==="closed"?To(n):Co(n,o,a),Be(n)}u(Rn,"ReadableByteStreamControllerRespondInternal");function Rt(n){return n._pendingPullIntos.shift()}u(Rt,"ReadableByteStreamControllerShiftPendingPullInto");function Po(n){const o=n._controlledReadableByteStream;return o._state!=="readable"||n._closeRequested||!n._started?!1:!!(an(o)&&yt(o)>0||hr(o)&&En(o)>0||Tn(n)>0)}u(Po,"ReadableByteStreamControllerShouldCallPull");function Tt(n){n._pullAlgorithm=void 0,n._cancelAlgorithm=void 0}u(Tt,"ReadableByteStreamControllerClearAlgorithms");function ot(n){const o=n._controlledReadableByteStream;if(!(n._closeRequested||o._state!=="readable")){if(n._queueTotalSize>0){n._closeRequested=!0;return}if(n._pendingPullIntos.length>0&&n._pendingPullIntos.peek().bytesFilled>0){const p=new TypeError("Insufficient bytes to fill elements in the given buffer");throw te(n,p),p}Tt(n),ft(o)}}u(ot,"ReadableByteStreamControllerClose");function Ct(n,o){const a=n._controlledReadableByteStream;if(n._closeRequested||a._state!=="readable")return;const p=o.buffer,g=o.byteOffset,_=o.byteLength,w=p;if(n._pendingPullIntos.length>0){const P=n._pendingPullIntos.peek();St(P.buffer),P.buffer=P.buffer}if(fr(n),an(a))if(yt(a)===0)wt(n,w,g,_);else{n._pendingPullIntos.length>0&&Rt(n);const P=new Uint8Array(w,g,_);ir(a,P,!1)}else hr(a)?(wt(n,w,g,_),wn(n)):wt(n,w,g,_);Be(n)}u(Ct,"ReadableByteStreamControllerEnqueue");function te(n,o){const a=n._controlledReadableByteStream;a._state==="readable"&&(mn(n),ye(n),Tt(n),Kn(a,o))}u(te,"ReadableByteStreamControllerError");function cr(n){if(n._byobRequest===null&&n._pendingPullIntos.length>0){const o=n._pendingPullIntos.peek(),a=new Uint8Array(o.buffer,o.byteOffset+o.bytesFilled,o.byteLength-o.bytesFilled),p=Object.create(Ee.prototype);Eo(p,n,a),n._byobRequest=p}return n._byobRequest}u(cr,"ReadableByteStreamControllerGetBYOBRequest");function Tn(n){const o=n._controlledReadableByteStream._state;return o==="errored"?null:o==="closed"?0:n._strategyHWM-n._queueTotalSize}u(Tn,"ReadableByteStreamControllerGetDesiredSize");function Pt(n,o){const a=n._pendingPullIntos.peek();if(n._controlledReadableByteStream._state==="closed"){if(o!==0)throw new TypeError("bytesWritten must be 0 when calling respond() on a closed stream")}else{if(o===0)throw new TypeError("bytesWritten must be greater than 0 when calling respond() on a readable stream");if(a.bytesFilled+o>a.byteLength)throw new RangeError("bytesWritten out of range")}a.buffer=a.buffer,Rn(n,o)}u(Pt,"ReadableByteStreamControllerRespond");function vt(n,o){const a=n._pendingPullIntos.peek();if(n._controlledReadableByteStream._state==="closed"){if(o.byteLength!==0)throw new TypeError("The view's length must be 0 when calling respondWithNewView() on a closed stream")}else if(o.byteLength===0)throw new TypeError("The view's length must be greater than 0 when calling respondWithNewView() on a readable stream");if(a.byteOffset+a.bytesFilled!==o.byteOffset)throw new RangeError("The region specified by view does not match byobRequest");if(a.bufferByteLength!==o.buffer.byteLength)throw new RangeError("The buffer of view has different capacity than byobRequest");if(a.bytesFilled+o.byteLength>a.byteLength)throw new RangeError("The region specified by view is larger than byobRequest");const g=o.byteLength;a.buffer=o.buffer,Rn(n,g)}u(vt,"ReadableByteStreamControllerRespondWithNewView");function Cn(n,o,a,p,g,_,w){o._controlledReadableByteStream=n,o._pullAgain=!1,o._pulling=!1,o._byobRequest=null,o._queue=o._queueTotalSize=void 0,ye(o),o._closeRequested=!1,o._started=!1,o._strategyHWM=_,o._pullAlgorithm=p,o._cancelAlgorithm=g,o._autoAllocateChunkSize=w,o._pendingPullIntos=new Y,n._readableStreamController=o;const P=a();D(T(P),()=>{o._started=!0,Be(o)},B=>{te(o,B)})}u(Cn,"SetUpReadableByteStreamController");function vo(n,o,a){const p=Object.create(ge.prototype);let g=u(()=>{},"startAlgorithm"),_=u(()=>T(void 0),"pullAlgorithm"),w=u(()=>T(void 0),"cancelAlgorithm");o.start!==void 0&&(g=u(()=>o.start(p),"startAlgorithm")),o.pull!==void 0&&(_=u(()=>o.pull(p),"pullAlgorithm")),o.cancel!==void 0&&(w=u(B=>o.cancel(B),"cancelAlgorithm"));const P=o.autoAllocateChunkSize;if(P===0)throw new TypeError("autoAllocateChunkSize must be greater than 0");Cn(n,p,g,_,w,a,P)}u(vo,"SetUpReadableByteStreamControllerFromUnderlyingSource");function Eo(n,o,a){n._associatedReadableByteStreamController=o,n._view=a}u(Eo,"SetUpReadableStreamBYOBRequest");function dr(n){return new TypeError(`ReadableStreamBYOBRequest.prototype.${n} can only be used on a ReadableStreamBYOBRequest`)}u(dr,"byobRequestBrandCheckException");function it(n){return new TypeError(`ReadableByteStreamController.prototype.${n} can only be used on a ReadableByteStreamController`)}u(it,"byteStreamControllerBrandCheckException");function Pn(n){return new We(n)}u(Pn,"AcquireReadableStreamBYOBReader");function vn(n,o){n._reader._readIntoRequests.push(o)}u(vn,"ReadableStreamAddReadIntoRequest");function Ao(n,o,a){const g=n._reader._readIntoRequests.shift();a?g._closeSteps(o):g._chunkSteps(o)}u(Ao,"ReadableStreamFulfillReadIntoRequest");function En(n){return n._reader._readIntoRequests.length}u(En,"ReadableStreamGetNumReadIntoRequests");function hr(n){const o=n._reader;return!(o===void 0||!ke(o))}u(hr,"ReadableStreamHasBYOBReader");const qr=class qr{constructor(o){if(de(o,1,"ReadableStreamBYOBReader"),or(o,"First parameter"),Te(o))throw new TypeError("This stream has already been locked for exclusive reading by another reader");if(!Ae(o._readableStreamController))throw new TypeError("Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source");Zr(this,o),this._readIntoRequests=new Y}get closed(){return ke(this)?this._closedPromise:v(Et("closed"))}cancel(o=void 0){return ke(this)?this._ownerReadableStream===void 0?v(Ue("cancel")):Kt(this,o):v(Et("cancel"))}read(o){if(!ke(this))return v(Et("read"));if(!ArrayBuffer.isView(o))return v(new TypeError("view must be an array buffer view"));if(o.byteLength===0)return v(new TypeError("view must have non-zero byteLength"));if(o.buffer.byteLength===0)return v(new TypeError("view's buffer must have non-zero byteLength"));if(St(o.buffer),this._ownerReadableStream===void 0)return v(Ue("read from"));let a,p;const g=F((w,P)=>{a=w,p=P});return An(this,o,{_chunkSteps:w=>a({value:w,done:!1}),_closeSteps:w=>a({value:w,done:!0}),_errorSteps:w=>p(w)}),g}releaseLock(){if(!ke(this))throw Et("releaseLock");if(this._ownerReadableStream!==void 0){if(this._readIntoRequests.length>0)throw new TypeError("Tried to release a reader lock when that reader has pending read() calls un-settled");fe(this)}}};u(qr,"ReadableStreamBYOBReader");let We=qr;Object.defineProperties(We.prototype,{cancel:{enumerable:!0},read:{enumerable:!0},releaseLock:{enumerable:!0},closed:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(We.prototype,b.toStringTag,{value:"ReadableStreamBYOBReader",configurable:!0});function ke(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_readIntoRequests")?!1:n instanceof We}u(ke,"IsReadableStreamBYOBReader");function An(n,o,a){const p=n._ownerReadableStream;p._disturbed=!0,p._state==="errored"?a._errorSteps(p._storedError):Ro(p._readableStreamController,o,a)}u(An,"ReadableStreamBYOBReaderRead");function Et(n){return new TypeError(`ReadableStreamBYOBReader.prototype.${n} can only be used on a ReadableStreamBYOBReader`)}u(Et,"byobReaderBrandCheckException");function st(n,o){const{highWaterMark:a}=n;if(a===void 0)return o;if(dn(a)||a<0)throw new RangeError("Invalid highWaterMark");return a}u(st,"ExtractHighWaterMark");function At(n){const{size:o}=n;return o||(()=>1)}u(At,"ExtractSizeAlgorithm");function Bt(n,o){ce(n,o);const a=n?.highWaterMark,p=n?.size;return{highWaterMark:a===void 0?void 0:nr(a),size:p===void 0?void 0:Bo(p,`${o} has member 'size' that`)}}u(Bt,"convertQueuingStrategy");function Bo(n,o){return ee(n,o),a=>nr(n(a))}u(Bo,"convertQueuingStrategySize");function Wo(n,o){ce(n,o);const a=n?.abort,p=n?.close,g=n?.start,_=n?.type,w=n?.write;return{abort:a===void 0?void 0:ko(a,n,`${o} has member 'abort' that`),close:p===void 0?void 0:Oo(p,n,`${o} has member 'close' that`),start:g===void 0?void 0:qo(g,n,`${o} has member 'start' that`),write:w===void 0?void 0:zo(w,n,`${o} has member 'write' that`),type:_}}u(Wo,"convertUnderlyingSink");function ko(n,o,a){return ee(n,a),p=>le(n,o,[p])}u(ko,"convertUnderlyingSinkAbortCallback");function Oo(n,o,a){return ee(n,a),()=>le(n,o,[])}u(Oo,"convertUnderlyingSinkCloseCallback");function qo(n,o,a){return ee(n,a),p=>Pe(n,o,[p])}u(qo,"convertUnderlyingSinkStartCallback");function zo(n,o,a){return ee(n,a),(p,g)=>le(n,o,[p,g])}u(zo,"convertUnderlyingSinkWriteCallback");function Bn(n,o){if(!Ne(n))throw new TypeError(`${o} is not a WritableStream.`)}u(Bn,"assertWritableStream");function Fo(n){if(typeof n!="object"||n===null)return!1;try{return typeof n.aborted=="boolean"}catch{return!1}}u(Fo,"isAbortSignal");const jo=typeof AbortController=="function";function Io(){if(jo)return new AbortController}u(Io,"createAbortController");const zr=class zr{constructor(o={},a={}){o===void 0?o=null:rn(o,"First parameter");const p=Bt(a,"Second parameter"),g=Wo(o,"First parameter");if(kn(this),g.type!==void 0)throw new RangeError("Invalid type is specified");const w=At(p),P=st(p,1);Ko(this,g,P,w)}get locked(){if(!Ne(this))throw zt("locked");return He(this)}abort(o=void 0){return Ne(this)?He(this)?v(new TypeError("Cannot abort a stream that already has a writer")):Wt(this,o):v(zt("abort"))}close(){return Ne(this)?He(this)?v(new TypeError("Cannot close a stream that already has a writer")):se(this)?v(new TypeError("Cannot close an already-closing stream")):On(this):v(zt("close"))}getWriter(){if(!Ne(this))throw zt("getWriter");return Wn(this)}};u(zr,"WritableStream");let Oe=zr;Object.defineProperties(Oe.prototype,{abort:{enumerable:!0},close:{enumerable:!0},getWriter:{enumerable:!0},locked:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Oe.prototype,b.toStringTag,{value:"WritableStream",configurable:!0});function Wn(n){return new qe(n)}u(Wn,"AcquireWritableStreamDefaultWriter");function Lo(n,o,a,p,g=1,_=()=>1){const w=Object.create(Oe.prototype);kn(w);const P=Object.create(_e.prototype);return Ln(w,P,n,o,a,p,g,_),w}u(Lo,"CreateWritableStream");function kn(n){n._state="writable",n._storedError=void 0,n._writer=void 0,n._writableStreamController=void 0,n._writeRequests=new Y,n._inFlightWriteRequest=void 0,n._closeRequest=void 0,n._inFlightCloseRequest=void 0,n._pendingAbortRequest=void 0,n._backpressure=!1}u(kn,"InitializeWritableStream");function Ne(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_writableStreamController")?!1:n instanceof Oe}u(Ne,"IsWritableStream");function He(n){return n._writer!==void 0}u(He,"IsWritableStreamLocked");function Wt(n,o){var a;if(n._state==="closed"||n._state==="errored")return T(void 0);n._writableStreamController._abortReason=o,(a=n._writableStreamController._abortController)===null||a===void 0||a.abort();const p=n._state;if(p==="closed"||p==="errored")return T(void 0);if(n._pendingAbortRequest!==void 0)return n._pendingAbortRequest._promise;let g=!1;p==="erroring"&&(g=!0,o=void 0);const _=F((w,P)=>{n._pendingAbortRequest={_promise:void 0,_resolve:w,_reject:P,_reason:o,_wasAlreadyErroring:g}});return n._pendingAbortRequest._promise=_,g||br(n,o),_}u(Wt,"WritableStreamAbort");function On(n){const o=n._state;if(o==="closed"||o==="errored")return v(new TypeError(`The stream (in ${o} state) is not in the writable state and cannot be closed`));const a=F((g,_)=>{const w={_resolve:g,_reject:_};n._closeRequest=w}),p=n._writer;return p!==void 0&&n._backpressure&&o==="writable"&&Cr(p),Jo(n._writableStreamController),a}u(On,"WritableStreamClose");function $o(n){return F((a,p)=>{const g={_resolve:a,_reject:p};n._writeRequests.push(g)})}u($o,"WritableStreamAddWriteRequest");function pr(n,o){if(n._state==="writable"){br(n,o);return}mr(n)}u(pr,"WritableStreamDealWithRejection");function br(n,o){const a=n._writableStreamController;n._state="erroring",n._storedError=o;const p=n._writer;p!==void 0&&zn(p,o),!No(n)&&a._started&&mr(n)}u(br,"WritableStreamStartErroring");function mr(n){n._state="errored",n._writableStreamController[en]();const o=n._storedError;if(n._writeRequests.forEach(g=>{g._reject(o)}),n._writeRequests=new Y,n._pendingAbortRequest===void 0){kt(n);return}const a=n._pendingAbortRequest;if(n._pendingAbortRequest=void 0,a._wasAlreadyErroring){a._reject(o),kt(n);return}const p=n._writableStreamController[Xr](a._reason);D(p,()=>{a._resolve(),kt(n)},g=>{a._reject(g),kt(n)})}u(mr,"WritableStreamFinishErroring");function Do(n){n._inFlightWriteRequest._resolve(void 0),n._inFlightWriteRequest=void 0}u(Do,"WritableStreamFinishInFlightWrite");function Mo(n,o){n._inFlightWriteRequest._reject(o),n._inFlightWriteRequest=void 0,pr(n,o)}u(Mo,"WritableStreamFinishInFlightWriteWithError");function Uo(n){n._inFlightCloseRequest._resolve(void 0),n._inFlightCloseRequest=void 0,n._state==="erroring"&&(n._storedError=void 0,n._pendingAbortRequest!==void 0&&(n._pendingAbortRequest._resolve(),n._pendingAbortRequest=void 0)),n._state="closed";const a=n._writer;a!==void 0&&Un(a)}u(Uo,"WritableStreamFinishInFlightClose");function xo(n,o){n._inFlightCloseRequest._reject(o),n._inFlightCloseRequest=void 0,n._pendingAbortRequest!==void 0&&(n._pendingAbortRequest._reject(o),n._pendingAbortRequest=void 0),pr(n,o)}u(xo,"WritableStreamFinishInFlightCloseWithError");function se(n){return!(n._closeRequest===void 0&&n._inFlightCloseRequest===void 0)}u(se,"WritableStreamCloseQueuedOrInFlight");function No(n){return!(n._inFlightWriteRequest===void 0&&n._inFlightCloseRequest===void 0)}u(No,"WritableStreamHasOperationMarkedInFlight");function Ho(n){n._inFlightCloseRequest=n._closeRequest,n._closeRequest=void 0}u(Ho,"WritableStreamMarkCloseRequestInFlight");function Vo(n){n._inFlightWriteRequest=n._writeRequests.shift()}u(Vo,"WritableStreamMarkFirstWriteRequestInFlight");function kt(n){n._closeRequest!==void 0&&(n._closeRequest._reject(n._storedError),n._closeRequest=void 0);const o=n._writer;o!==void 0&&Rr(o,n._storedError)}u(kt,"WritableStreamRejectCloseAndClosedPromiseIfNeeded");function yr(n,o){const a=n._writer;a!==void 0&&o!==n._backpressure&&(o?ii(a):Cr(a)),n._backpressure=o}u(yr,"WritableStreamUpdateBackpressure");const Fr=class Fr{constructor(o){if(de(o,1,"WritableStreamDefaultWriter"),Bn(o,"First parameter"),He(o))throw new TypeError("This stream has already been locked for exclusive writing by another writer");this._ownerWritableStream=o,o._writer=this;const a=o._state;if(a==="writable")!se(o)&&o._backpressure?jt(this):xn(this),Ft(this);else if(a==="erroring")Tr(this,o._storedError),Ft(this);else if(a==="closed")xn(this),ni(this);else{const p=o._storedError;Tr(this,p),Mn(this,p)}}get closed(){return ze(this)?this._closedPromise:v(Fe("closed"))}get desiredSize(){if(!ze(this))throw Fe("desiredSize");if(this._ownerWritableStream===void 0)throw at("desiredSize");return Zo(this)}get ready(){return ze(this)?this._readyPromise:v(Fe("ready"))}abort(o=void 0){return ze(this)?this._ownerWritableStream===void 0?v(at("abort")):Qo(this,o):v(Fe("abort"))}close(){if(!ze(this))return v(Fe("close"));const o=this._ownerWritableStream;return o===void 0?v(at("close")):se(o)?v(new TypeError("Cannot close an already-closing stream")):qn(this)}releaseLock(){if(!ze(this))throw Fe("releaseLock");this._ownerWritableStream!==void 0&&Fn(this)}write(o=void 0){return ze(this)?this._ownerWritableStream===void 0?v(at("write to")):jn(this,o):v(Fe("write"))}};u(Fr,"WritableStreamDefaultWriter");let qe=Fr;Object.defineProperties(qe.prototype,{abort:{enumerable:!0},close:{enumerable:!0},releaseLock:{enumerable:!0},write:{enumerable:!0},closed:{enumerable:!0},desiredSize:{enumerable:!0},ready:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(qe.prototype,b.toStringTag,{value:"WritableStreamDefaultWriter",configurable:!0});function ze(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_ownerWritableStream")?!1:n instanceof qe}u(ze,"IsWritableStreamDefaultWriter");function Qo(n,o){const a=n._ownerWritableStream;return Wt(a,o)}u(Qo,"WritableStreamDefaultWriterAbort");function qn(n){const o=n._ownerWritableStream;return On(o)}u(qn,"WritableStreamDefaultWriterClose");function Go(n){const o=n._ownerWritableStream,a=o._state;return se(o)||a==="closed"?T(void 0):a==="errored"?v(o._storedError):qn(n)}u(Go,"WritableStreamDefaultWriterCloseWithErrorPropagation");function Yo(n,o){n._closedPromiseState==="pending"?Rr(n,o):oi(n,o)}u(Yo,"WritableStreamDefaultWriterEnsureClosedPromiseRejected");function zn(n,o){n._readyPromiseState==="pending"?Nn(n,o):si(n,o)}u(zn,"WritableStreamDefaultWriterEnsureReadyPromiseRejected");function Zo(n){const o=n._ownerWritableStream,a=o._state;return a==="errored"||a==="erroring"?null:a==="closed"?0:$n(o._writableStreamController)}u(Zo,"WritableStreamDefaultWriterGetDesiredSize");function Fn(n){const o=n._ownerWritableStream,a=new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");zn(n,a),Yo(n,a),o._writer=void 0,n._ownerWritableStream=void 0}u(Fn,"WritableStreamDefaultWriterRelease");function jn(n,o){const a=n._ownerWritableStream,p=a._writableStreamController,g=Xo(p,o);if(a!==n._ownerWritableStream)return v(at("write to"));const _=a._state;if(_==="errored")return v(a._storedError);if(se(a)||_==="closed")return v(new TypeError("The stream is closing or closed and cannot be written to"));if(_==="erroring")return v(a._storedError);const w=$o(a);return ei(p,o,g),w}u(jn,"WritableStreamDefaultWriterWrite");const In={},jr=class jr{constructor(){throw new TypeError("Illegal constructor")}get abortReason(){if(!gr(this))throw wr("abortReason");return this._abortReason}get signal(){if(!gr(this))throw wr("signal");if(this._abortController===void 0)throw new TypeError("WritableStreamDefaultController.prototype.signal is not supported");return this._abortController.signal}error(o=void 0){if(!gr(this))throw wr("error");this._controlledWritableStream._state==="writable"&&Dn(this,o)}[Xr](o){const a=this._abortAlgorithm(o);return Ot(this),a}[en](){ye(this)}};u(jr,"WritableStreamDefaultController");let _e=jr;Object.defineProperties(_e.prototype,{abortReason:{enumerable:!0},signal:{enumerable:!0},error:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(_e.prototype,b.toStringTag,{value:"WritableStreamDefaultController",configurable:!0});function gr(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_controlledWritableStream")?!1:n instanceof _e}u(gr,"IsWritableStreamDefaultController");function Ln(n,o,a,p,g,_,w,P){o._controlledWritableStream=n,n._writableStreamController=o,o._queue=void 0,o._queueTotalSize=void 0,ye(o),o._abortReason=void 0,o._abortController=Io(),o._started=!1,o._strategySizeAlgorithm=P,o._strategyHWM=w,o._writeAlgorithm=p,o._closeAlgorithm=g,o._abortAlgorithm=_;const B=Sr(o);yr(n,B);const k=a(),q=T(k);D(q,()=>{o._started=!0,qt(o)},z=>{o._started=!0,pr(n,z)})}u(Ln,"SetUpWritableStreamDefaultController");function Ko(n,o,a,p){const g=Object.create(_e.prototype);let _=u(()=>{},"startAlgorithm"),w=u(()=>T(void 0),"writeAlgorithm"),P=u(()=>T(void 0),"closeAlgorithm"),B=u(()=>T(void 0),"abortAlgorithm");o.start!==void 0&&(_=u(()=>o.start(g),"startAlgorithm")),o.write!==void 0&&(w=u(k=>o.write(k,g),"writeAlgorithm")),o.close!==void 0&&(P=u(()=>o.close(),"closeAlgorithm")),o.abort!==void 0&&(B=u(k=>o.abort(k),"abortAlgorithm")),Ln(n,g,_,w,P,B,a,p)}u(Ko,"SetUpWritableStreamDefaultControllerFromUnderlyingSink");function Ot(n){n._writeAlgorithm=void 0,n._closeAlgorithm=void 0,n._abortAlgorithm=void 0,n._strategySizeAlgorithm=void 0}u(Ot,"WritableStreamDefaultControllerClearAlgorithms");function Jo(n){ar(n,In,0),qt(n)}u(Jo,"WritableStreamDefaultControllerClose");function Xo(n,o){try{return n._strategySizeAlgorithm(o)}catch(a){return _r(n,a),1}}u(Xo,"WritableStreamDefaultControllerGetChunkSize");function $n(n){return n._strategyHWM-n._queueTotalSize}u($n,"WritableStreamDefaultControllerGetDesiredSize");function ei(n,o,a){try{ar(n,o,a)}catch(g){_r(n,g);return}const p=n._controlledWritableStream;if(!se(p)&&p._state==="writable"){const g=Sr(n);yr(p,g)}qt(n)}u(ei,"WritableStreamDefaultControllerWrite");function qt(n){const o=n._controlledWritableStream;if(!n._started||o._inFlightWriteRequest!==void 0)return;if(o._state==="erroring"){mr(o);return}if(n._queue.length===0)return;const p=wo(n);p===In?ti(n):ri(n,p)}u(qt,"WritableStreamDefaultControllerAdvanceQueueIfNeeded");function _r(n,o){n._controlledWritableStream._state==="writable"&&Dn(n,o)}u(_r,"WritableStreamDefaultControllerErrorIfNeeded");function ti(n){const o=n._controlledWritableStream;Ho(o),sr(n);const a=n._closeAlgorithm();Ot(n),D(a,()=>{Uo(o)},p=>{xo(o,p)})}u(ti,"WritableStreamDefaultControllerProcessClose");function ri(n,o){const a=n._controlledWritableStream;Vo(a);const p=n._writeAlgorithm(o);D(p,()=>{Do(a);const g=a._state;if(sr(n),!se(a)&&g==="writable"){const _=Sr(n);yr(a,_)}qt(n)},g=>{a._state==="writable"&&Ot(n),Mo(a,g)})}u(ri,"WritableStreamDefaultControllerProcessWrite");function Sr(n){return $n(n)<=0}u(Sr,"WritableStreamDefaultControllerGetBackpressure");function Dn(n,o){const a=n._controlledWritableStream;Ot(n),br(a,o)}u(Dn,"WritableStreamDefaultControllerError");function zt(n){return new TypeError(`WritableStream.prototype.${n} can only be used on a WritableStream`)}u(zt,"streamBrandCheckException$2");function wr(n){return new TypeError(`WritableStreamDefaultController.prototype.${n} can only be used on a WritableStreamDefaultController`)}u(wr,"defaultControllerBrandCheckException$2");function Fe(n){return new TypeError(`WritableStreamDefaultWriter.prototype.${n} can only be used on a WritableStreamDefaultWriter`)}u(Fe,"defaultWriterBrandCheckException");function at(n){return new TypeError("Cannot "+n+" a stream using a released writer")}u(at,"defaultWriterLockException");function Ft(n){n._closedPromise=F((o,a)=>{n._closedPromise_resolve=o,n._closedPromise_reject=a,n._closedPromiseState="pending"})}u(Ft,"defaultWriterClosedPromiseInitialize");function Mn(n,o){Ft(n),Rr(n,o)}u(Mn,"defaultWriterClosedPromiseInitializeAsRejected");function ni(n){Ft(n),Un(n)}u(ni,"defaultWriterClosedPromiseInitializeAsResolved");function Rr(n,o){n._closedPromise_reject!==void 0&&(V(n._closedPromise),n._closedPromise_reject(o),n._closedPromise_resolve=void 0,n._closedPromise_reject=void 0,n._closedPromiseState="rejected")}u(Rr,"defaultWriterClosedPromiseReject");function oi(n,o){Mn(n,o)}u(oi,"defaultWriterClosedPromiseResetToRejected");function Un(n){n._closedPromise_resolve!==void 0&&(n._closedPromise_resolve(void 0),n._closedPromise_resolve=void 0,n._closedPromise_reject=void 0,n._closedPromiseState="resolved")}u(Un,"defaultWriterClosedPromiseResolve");function jt(n){n._readyPromise=F((o,a)=>{n._readyPromise_resolve=o,n._readyPromise_reject=a}),n._readyPromiseState="pending"}u(jt,"defaultWriterReadyPromiseInitialize");function Tr(n,o){jt(n),Nn(n,o)}u(Tr,"defaultWriterReadyPromiseInitializeAsRejected");function xn(n){jt(n),Cr(n)}u(xn,"defaultWriterReadyPromiseInitializeAsResolved");function Nn(n,o){n._readyPromise_reject!==void 0&&(V(n._readyPromise),n._readyPromise_reject(o),n._readyPromise_resolve=void 0,n._readyPromise_reject=void 0,n._readyPromiseState="rejected")}u(Nn,"defaultWriterReadyPromiseReject");function ii(n){jt(n)}u(ii,"defaultWriterReadyPromiseReset");function si(n,o){Tr(n,o)}u(si,"defaultWriterReadyPromiseResetToRejected");function Cr(n){n._readyPromise_resolve!==void 0&&(n._readyPromise_resolve(void 0),n._readyPromise_resolve=void 0,n._readyPromise_reject=void 0,n._readyPromiseState="fulfilled")}u(Cr,"defaultWriterReadyPromiseResolve");const Hn=typeof DOMException<"u"?DOMException:void 0;function ai(n){if(!(typeof n=="function"||typeof n=="object"))return!1;try{return new n,!0}catch{return!1}}u(ai,"isDOMExceptionConstructor");function ui(){const n=u(function(a,p){this.message=a||"",this.name=p||"Error",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)},"DOMException");return n.prototype=Object.create(Error.prototype),Object.defineProperty(n.prototype,"constructor",{value:n,writable:!0,configurable:!0}),n}u(ui,"createDOMExceptionPolyfill");const li=ai(Hn)?Hn:ui();function Vn(n,o,a,p,g,_){const w=xe(n),P=Wn(o);n._disturbed=!0;let B=!1,k=T(void 0);return F((q,z)=>{let M;if(_!==void 0){if(M=u(()=>{const E=new li("Aborted","AbortError"),W=[];p||W.push(()=>o._state==="writable"?Wt(o,E):T(void 0)),g||W.push(()=>n._state==="readable"?re(n,E):T(void 0)),G(()=>Promise.all(W.map(I=>I())),!0,E)},"abortAlgorithm"),_.aborted){M();return}_.addEventListener("abort",M)}function ne(){return F((E,W)=>{function I(Z){Z?E():j(Ze(),I,W)}u(I,"next"),I(!1)})}u(ne,"pipeLoop");function Ze(){return B?T(!0):j(P._readyPromise,()=>F((E,W)=>{rt(w,{_chunkSteps:I=>{k=j(jn(P,I),void 0,y),E(!1)},_closeSteps:()=>E(!0),_errorSteps:W})}))}if(u(Ze,"pipeStep"),he(n,w._closedPromise,E=>{p?K(!0,E):G(()=>Wt(o,E),!0,E)}),he(o,P._closedPromise,E=>{g?K(!0,E):G(()=>re(n,E),!0,E)}),Q(n,w._closedPromise,()=>{a?K():G(()=>Go(P))}),se(o)||o._state==="closed"){const E=new TypeError("the destination writable stream closed before all data could be piped to it");g?K(!0,E):G(()=>re(n,E),!0,E)}V(ne());function Ce(){const E=k;return j(k,()=>E!==k?Ce():void 0)}u(Ce,"waitForWritesToFinish");function he(E,W,I){E._state==="errored"?I(E._storedError):tt(W,I)}u(he,"isOrBecomesErrored");function Q(E,W,I){E._state==="closed"?I():ie(W,I)}u(Q,"isOrBecomesClosed");function G(E,W,I){if(B)return;B=!0,o._state==="writable"&&!se(o)?ie(Ce(),Z):Z();function Z(){D(E(),()=>pe(W,I),Ke=>pe(!0,Ke))}u(Z,"doTheRest")}u(G,"shutdownWithAction");function K(E,W){B||(B=!0,o._state==="writable"&&!se(o)?ie(Ce(),()=>pe(E,W)):pe(E,W))}u(K,"shutdown");function pe(E,W){Fn(P),fe(w),_!==void 0&&_.removeEventListener("abort",M),E?z(W):q(void 0)}u(pe,"finalize")})}u(Vn,"ReadableStreamPipeTo");const Ir=class Ir{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!It(this))throw Dt("desiredSize");return Pr(this)}close(){if(!It(this))throw Dt("close");if(!Ve(this))throw new TypeError("The stream is not in a state that permits close");lt(this)}enqueue(o=void 0){if(!It(this))throw Dt("enqueue");if(!Ve(this))throw new TypeError("The stream is not in a state that permits enqueue");return $t(this,o)}error(o=void 0){if(!It(this))throw Dt("error");we(this,o)}[er](o){ye(this);const a=this._cancelAlgorithm(o);return Lt(this),a}[tr](o){const a=this._controlledReadableStream;if(this._queue.length>0){const p=sr(this);this._closeRequested&&this._queue.length===0?(Lt(this),ft(a)):ut(this),o._chunkSteps(p)}else sn(a,o),ut(this)}};u(Ir,"ReadableStreamDefaultController");let Se=Ir;Object.defineProperties(Se.prototype,{close:{enumerable:!0},enqueue:{enumerable:!0},error:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Se.prototype,b.toStringTag,{value:"ReadableStreamDefaultController",configurable:!0});function It(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_controlledReadableStream")?!1:n instanceof Se}u(It,"IsReadableStreamDefaultController");function ut(n){if(!Qn(n))return;if(n._pulling){n._pullAgain=!0;return}n._pulling=!0;const a=n._pullAlgorithm();D(a,()=>{n._pulling=!1,n._pullAgain&&(n._pullAgain=!1,ut(n))},p=>{we(n,p)})}u(ut,"ReadableStreamDefaultControllerCallPullIfNeeded");function Qn(n){const o=n._controlledReadableStream;return!Ve(n)||!n._started?!1:!!(Te(o)&&yt(o)>0||Pr(n)>0)}u(Qn,"ReadableStreamDefaultControllerShouldCallPull");function Lt(n){n._pullAlgorithm=void 0,n._cancelAlgorithm=void 0,n._strategySizeAlgorithm=void 0}u(Lt,"ReadableStreamDefaultControllerClearAlgorithms");function lt(n){if(!Ve(n))return;const o=n._controlledReadableStream;n._closeRequested=!0,n._queue.length===0&&(Lt(n),ft(o))}u(lt,"ReadableStreamDefaultControllerClose");function $t(n,o){if(!Ve(n))return;const a=n._controlledReadableStream;if(Te(a)&&yt(a)>0)ir(a,o,!1);else{let p;try{p=n._strategySizeAlgorithm(o)}catch(g){throw we(n,g),g}try{ar(n,o,p)}catch(g){throw we(n,g),g}}ut(n)}u($t,"ReadableStreamDefaultControllerEnqueue");function we(n,o){const a=n._controlledReadableStream;a._state==="readable"&&(ye(n),Lt(n),Kn(a,o))}u(we,"ReadableStreamDefaultControllerError");function Pr(n){const o=n._controlledReadableStream._state;return o==="errored"?null:o==="closed"?0:n._strategyHWM-n._queueTotalSize}u(Pr,"ReadableStreamDefaultControllerGetDesiredSize");function fi(n){return!Qn(n)}u(fi,"ReadableStreamDefaultControllerHasBackpressure");function Ve(n){const o=n._controlledReadableStream._state;return!n._closeRequested&&o==="readable"}u(Ve,"ReadableStreamDefaultControllerCanCloseOrEnqueue");function Gn(n,o,a,p,g,_,w){o._controlledReadableStream=n,o._queue=void 0,o._queueTotalSize=void 0,ye(o),o._started=!1,o._closeRequested=!1,o._pullAgain=!1,o._pulling=!1,o._strategySizeAlgorithm=w,o._strategyHWM=_,o._pullAlgorithm=p,o._cancelAlgorithm=g,n._readableStreamController=o;const P=a();D(T(P),()=>{o._started=!0,ut(o)},B=>{we(o,B)})}u(Gn,"SetUpReadableStreamDefaultController");function ci(n,o,a,p){const g=Object.create(Se.prototype);let _=u(()=>{},"startAlgorithm"),w=u(()=>T(void 0),"pullAlgorithm"),P=u(()=>T(void 0),"cancelAlgorithm");o.start!==void 0&&(_=u(()=>o.start(g),"startAlgorithm")),o.pull!==void 0&&(w=u(()=>o.pull(g),"pullAlgorithm")),o.cancel!==void 0&&(P=u(B=>o.cancel(B),"cancelAlgorithm")),Gn(n,g,_,w,P,a,p)}u(ci,"SetUpReadableStreamDefaultControllerFromUnderlyingSource");function Dt(n){return new TypeError(`ReadableStreamDefaultController.prototype.${n} can only be used on a ReadableStreamDefaultController`)}u(Dt,"defaultControllerBrandCheckException$1");function di(n,o){return Ae(n._readableStreamController)?pi(n):hi(n)}u(di,"ReadableStreamTee");function hi(n,o){const a=xe(n);let p=!1,g=!1,_=!1,w=!1,P,B,k,q,z;const M=F(Q=>{z=Q});function ne(){return p?(g=!0,T(void 0)):(p=!0,rt(a,{_chunkSteps:G=>{U(()=>{g=!1;const K=G,pe=G;_||$t(k._readableStreamController,K),w||$t(q._readableStreamController,pe),p=!1,g&&ne()})},_closeSteps:()=>{p=!1,_||lt(k._readableStreamController),w||lt(q._readableStreamController),(!_||!w)&&z(void 0)},_errorSteps:()=>{p=!1}}),T(void 0))}u(ne,"pullAlgorithm");function Ze(Q){if(_=!0,P=Q,w){const G=nt([P,B]),K=re(n,G);z(K)}return M}u(Ze,"cancel1Algorithm");function Ce(Q){if(w=!0,B=Q,_){const G=nt([P,B]),K=re(n,G);z(K)}return M}u(Ce,"cancel2Algorithm");function he(){}return u(he,"startAlgorithm"),k=vr(he,ne,Ze),q=vr(he,ne,Ce),tt(a._closedPromise,Q=>{we(k._readableStreamController,Q),we(q._readableStreamController,Q),(!_||!w)&&z(void 0)}),[k,q]}u(hi,"ReadableStreamDefaultTee");function pi(n){let o=xe(n),a=!1,p=!1,g=!1,_=!1,w=!1,P,B,k,q,z;const M=F(E=>{z=E});function ne(E){tt(E._closedPromise,W=>{E===o&&(te(k._readableStreamController,W),te(q._readableStreamController,W),(!_||!w)&&z(void 0))})}u(ne,"forwardReaderError");function Ze(){ke(o)&&(fe(o),o=xe(n),ne(o)),rt(o,{_chunkSteps:W=>{U(()=>{p=!1,g=!1;const I=W;let Z=W;if(!_&&!w)try{Z=bn(W)}catch(Ke){te(k._readableStreamController,Ke),te(q._readableStreamController,Ke),z(re(n,Ke));return}_||Ct(k._readableStreamController,I),w||Ct(q._readableStreamController,Z),a=!1,p?he():g&&Q()})},_closeSteps:()=>{a=!1,_||ot(k._readableStreamController),w||ot(q._readableStreamController),k._readableStreamController._pendingPullIntos.length>0&&Pt(k._readableStreamController,0),q._readableStreamController._pendingPullIntos.length>0&&Pt(q._readableStreamController,0),(!_||!w)&&z(void 0)},_errorSteps:()=>{a=!1}})}u(Ze,"pullWithDefaultReader");function Ce(E,W){me(o)&&(fe(o),o=Pn(n),ne(o));const I=W?q:k,Z=W?k:q;An(o,E,{_chunkSteps:Je=>{U(()=>{p=!1,g=!1;const Xe=W?w:_;if(W?_:w)Xe||vt(I._readableStreamController,Je);else{let fo;try{fo=bn(Je)}catch(xr){te(I._readableStreamController,xr),te(Z._readableStreamController,xr),z(re(n,xr));return}Xe||vt(I._readableStreamController,Je),Ct(Z._readableStreamController,fo)}a=!1,p?he():g&&Q()})},_closeSteps:Je=>{a=!1;const Xe=W?w:_,Vt=W?_:w;Xe||ot(I._readableStreamController),Vt||ot(Z._readableStreamController),Je!==void 0&&(Xe||vt(I._readableStreamController,Je),!Vt&&Z._readableStreamController._pendingPullIntos.length>0&&Pt(Z._readableStreamController,0)),(!Xe||!Vt)&&z(void 0)},_errorSteps:()=>{a=!1}})}u(Ce,"pullWithBYOBReader");function he(){if(a)return p=!0,T(void 0);a=!0;const E=cr(k._readableStreamController);return E===null?Ze():Ce(E._view,!1),T(void 0)}u(he,"pull1Algorithm");function Q(){if(a)return g=!0,T(void 0);a=!0;const E=cr(q._readableStreamController);return E===null?Ze():Ce(E._view,!0),T(void 0)}u(Q,"pull2Algorithm");function G(E){if(_=!0,P=E,w){const W=nt([P,B]),I=re(n,W);z(I)}return M}u(G,"cancel1Algorithm");function K(E){if(w=!0,B=E,_){const W=nt([P,B]),I=re(n,W);z(I)}return M}u(K,"cancel2Algorithm");function pe(){}return u(pe,"startAlgorithm"),k=Zn(pe,he,G),q=Zn(pe,Q,K),ne(o),[k,q]}u(pi,"ReadableByteStreamTee");function bi(n,o){ce(n,o);const a=n,p=a?.autoAllocateChunkSize,g=a?.cancel,_=a?.pull,w=a?.start,P=a?.type;return{autoAllocateChunkSize:p===void 0?void 0:on(p,`${o} has member 'autoAllocateChunkSize' that`),cancel:g===void 0?void 0:mi(g,a,`${o} has member 'cancel' that`),pull:_===void 0?void 0:yi(_,a,`${o} has member 'pull' that`),start:w===void 0?void 0:gi(w,a,`${o} has member 'start' that`),type:P===void 0?void 0:_i(P,`${o} has member 'type' that`)}}u(bi,"convertUnderlyingDefaultOrByteSource");function mi(n,o,a){return ee(n,a),p=>le(n,o,[p])}u(mi,"convertUnderlyingSourceCancelCallback");function yi(n,o,a){return ee(n,a),p=>le(n,o,[p])}u(yi,"convertUnderlyingSourcePullCallback");function gi(n,o,a){return ee(n,a),p=>Pe(n,o,[p])}u(gi,"convertUnderlyingSourceStartCallback");function _i(n,o){if(n=`${n}`,n!=="bytes")throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamType`);return n}u(_i,"convertReadableStreamType");function Si(n,o){ce(n,o);const a=n?.mode;return{mode:a===void 0?void 0:wi(a,`${o} has member 'mode' that`)}}u(Si,"convertReaderOptions");function wi(n,o){if(n=`${n}`,n!=="byob")throw new TypeError(`${o} '${n}' is not a valid enumeration value for ReadableStreamReaderMode`);return n}u(wi,"convertReadableStreamReaderMode");function Ri(n,o){return ce(n,o),{preventCancel:!!n?.preventCancel}}u(Ri,"convertIteratorOptions");function Yn(n,o){ce(n,o);const a=n?.preventAbort,p=n?.preventCancel,g=n?.preventClose,_=n?.signal;return _!==void 0&&Ti(_,`${o} has member 'signal' that`),{preventAbort:!!a,preventCancel:!!p,preventClose:!!g,signal:_}}u(Yn,"convertPipeOptions");function Ti(n,o){if(!Fo(n))throw new TypeError(`${o} is not an AbortSignal.`)}u(Ti,"assertAbortSignal");function Ci(n,o){ce(n,o);const a=n?.readable;rr(a,"readable","ReadableWritablePair"),or(a,`${o} has member 'readable' that`);const p=n?.writable;return rr(p,"writable","ReadableWritablePair"),Bn(p,`${o} has member 'writable' that`),{readable:a,writable:p}}u(Ci,"convertReadableWritablePair");const Lr=class Lr{constructor(o={},a={}){o===void 0?o=null:rn(o,"First parameter");const p=Bt(a,"Second parameter"),g=bi(o,"First parameter");if(Er(this),g.type==="bytes"){if(p.size!==void 0)throw new RangeError("The strategy for a byte stream cannot have a size function");const _=st(p,0);vo(this,g,_)}else{const _=At(p),w=st(p,1);ci(this,g,w,_)}}get locked(){if(!Re(this))throw je("locked");return Te(this)}cancel(o=void 0){return Re(this)?Te(this)?v(new TypeError("Cannot cancel a stream that already has a reader")):re(this,o):v(je("cancel"))}getReader(o=void 0){if(!Re(this))throw je("getReader");return Si(o,"First parameter").mode===void 0?xe(this):Pn(this)}pipeThrough(o,a={}){if(!Re(this))throw je("pipeThrough");de(o,1,"pipeThrough");const p=Ci(o,"First parameter"),g=Yn(a,"Second parameter");if(Te(this))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream");if(He(p.writable))throw new TypeError("ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream");const _=Vn(this,p.writable,g.preventClose,g.preventAbort,g.preventCancel,g.signal);return V(_),p.readable}pipeTo(o,a={}){if(!Re(this))return v(je("pipeTo"));if(o===void 0)return v("Parameter 1 is required in 'pipeTo'.");if(!Ne(o))return v(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));let p;try{p=Yn(a,"Second parameter")}catch(g){return v(g)}return Te(this)?v(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream")):He(o)?v(new TypeError("ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream")):Vn(this,o,p.preventClose,p.preventAbort,p.preventCancel,p.signal)}tee(){if(!Re(this))throw je("tee");const o=di(this);return nt(o)}values(o=void 0){if(!Re(this))throw je("values");const a=Ri(o,"First parameter");return _o(this,a.preventCancel)}};u(Lr,"ReadableStream");let ae=Lr;Object.defineProperties(ae.prototype,{cancel:{enumerable:!0},getReader:{enumerable:!0},pipeThrough:{enumerable:!0},pipeTo:{enumerable:!0},tee:{enumerable:!0},values:{enumerable:!0},locked:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(ae.prototype,b.toStringTag,{value:"ReadableStream",configurable:!0}),typeof b.asyncIterator=="symbol"&&Object.defineProperty(ae.prototype,b.asyncIterator,{value:ae.prototype.values,writable:!0,configurable:!0});function vr(n,o,a,p=1,g=()=>1){const _=Object.create(ae.prototype);Er(_);const w=Object.create(Se.prototype);return Gn(_,w,n,o,a,p,g),_}u(vr,"CreateReadableStream");function Zn(n,o,a){const p=Object.create(ae.prototype);Er(p);const g=Object.create(ge.prototype);return Cn(p,g,n,o,a,0,void 0),p}u(Zn,"CreateReadableByteStream");function Er(n){n._state="readable",n._reader=void 0,n._storedError=void 0,n._disturbed=!1}u(Er,"InitializeReadableStream");function Re(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_readableStreamController")?!1:n instanceof ae}u(Re,"IsReadableStream");function Te(n){return n._reader!==void 0}u(Te,"IsReadableStreamLocked");function re(n,o){if(n._disturbed=!0,n._state==="closed")return T(void 0);if(n._state==="errored")return v(n._storedError);ft(n);const a=n._reader;a!==void 0&&ke(a)&&(a._readIntoRequests.forEach(g=>{g._closeSteps(void 0)}),a._readIntoRequests=new Y);const p=n._readableStreamController[er](o);return $(p,y)}u(re,"ReadableStreamCancel");function ft(n){n._state="closed";const o=n._reader;o!==void 0&&(Jr(o),me(o)&&(o._readRequests.forEach(a=>{a._closeSteps()}),o._readRequests=new Y))}u(ft,"ReadableStreamClose");function Kn(n,o){n._state="errored",n._storedError=o;const a=n._reader;a!==void 0&&(Xt(a,o),me(a)?(a._readRequests.forEach(p=>{p._errorSteps(o)}),a._readRequests=new Y):(a._readIntoRequests.forEach(p=>{p._errorSteps(o)}),a._readIntoRequests=new Y))}u(Kn,"ReadableStreamError");function je(n){return new TypeError(`ReadableStream.prototype.${n} can only be used on a ReadableStream`)}u(je,"streamBrandCheckException$1");function Jn(n,o){ce(n,o);const a=n?.highWaterMark;return rr(a,"highWaterMark","QueuingStrategyInit"),{highWaterMark:nr(a)}}u(Jn,"convertQueuingStrategyInit");const Xn=u(n=>n.byteLength,"byteLengthSizeFunction");try{Object.defineProperty(Xn,"name",{value:"size",configurable:!0})}catch{}const $r=class $r{constructor(o){de(o,1,"ByteLengthQueuingStrategy"),o=Jn(o,"First parameter"),this._byteLengthQueuingStrategyHighWaterMark=o.highWaterMark}get highWaterMark(){if(!to(this))throw eo("highWaterMark");return this._byteLengthQueuingStrategyHighWaterMark}get size(){if(!to(this))throw eo("size");return Xn}};u($r,"ByteLengthQueuingStrategy");let Qe=$r;Object.defineProperties(Qe.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Qe.prototype,b.toStringTag,{value:"ByteLengthQueuingStrategy",configurable:!0});function eo(n){return new TypeError(`ByteLengthQueuingStrategy.prototype.${n} can only be used on a ByteLengthQueuingStrategy`)}u(eo,"byteLengthBrandCheckException");function to(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_byteLengthQueuingStrategyHighWaterMark")?!1:n instanceof Qe}u(to,"IsByteLengthQueuingStrategy");const ro=u(()=>1,"countSizeFunction");try{Object.defineProperty(ro,"name",{value:"size",configurable:!0})}catch{}const Dr=class Dr{constructor(o){de(o,1,"CountQueuingStrategy"),o=Jn(o,"First parameter"),this._countQueuingStrategyHighWaterMark=o.highWaterMark}get highWaterMark(){if(!oo(this))throw no("highWaterMark");return this._countQueuingStrategyHighWaterMark}get size(){if(!oo(this))throw no("size");return ro}};u(Dr,"CountQueuingStrategy");let Ge=Dr;Object.defineProperties(Ge.prototype,{highWaterMark:{enumerable:!0},size:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ge.prototype,b.toStringTag,{value:"CountQueuingStrategy",configurable:!0});function no(n){return new TypeError(`CountQueuingStrategy.prototype.${n} can only be used on a CountQueuingStrategy`)}u(no,"countBrandCheckException");function oo(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_countQueuingStrategyHighWaterMark")?!1:n instanceof Ge}u(oo,"IsCountQueuingStrategy");function Pi(n,o){ce(n,o);const a=n?.flush,p=n?.readableType,g=n?.start,_=n?.transform,w=n?.writableType;return{flush:a===void 0?void 0:vi(a,n,`${o} has member 'flush' that`),readableType:p,start:g===void 0?void 0:Ei(g,n,`${o} has member 'start' that`),transform:_===void 0?void 0:Ai(_,n,`${o} has member 'transform' that`),writableType:w}}u(Pi,"convertTransformer");function vi(n,o,a){return ee(n,a),p=>le(n,o,[p])}u(vi,"convertTransformerFlushCallback");function Ei(n,o,a){return ee(n,a),p=>Pe(n,o,[p])}u(Ei,"convertTransformerStartCallback");function Ai(n,o,a){return ee(n,a),(p,g)=>le(n,o,[p,g])}u(Ai,"convertTransformerTransformCallback");const Mr=class Mr{constructor(o={},a={},p={}){o===void 0&&(o=null);const g=Bt(a,"Second parameter"),_=Bt(p,"Third parameter"),w=Pi(o,"First parameter");if(w.readableType!==void 0)throw new RangeError("Invalid readableType specified");if(w.writableType!==void 0)throw new RangeError("Invalid writableType specified");const P=st(_,0),B=At(_),k=st(g,1),q=At(g);let z;const M=F(ne=>{z=ne});Bi(this,M,k,q,P,B),ki(this,w),w.start!==void 0?z(w.start(this._transformStreamController)):z(void 0)}get readable(){if(!io(this))throw lo("readable");return this._readable}get writable(){if(!io(this))throw lo("writable");return this._writable}};u(Mr,"TransformStream");let Ye=Mr;Object.defineProperties(Ye.prototype,{readable:{enumerable:!0},writable:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ye.prototype,b.toStringTag,{value:"TransformStream",configurable:!0});function Bi(n,o,a,p,g,_){function w(){return o}u(w,"startAlgorithm");function P(M){return zi(n,M)}u(P,"writeAlgorithm");function B(M){return Fi(n,M)}u(B,"abortAlgorithm");function k(){return ji(n)}u(k,"closeAlgorithm"),n._writable=Lo(w,P,k,B,a,p);function q(){return Ii(n)}u(q,"pullAlgorithm");function z(M){return Ut(n,M),T(void 0)}u(z,"cancelAlgorithm"),n._readable=vr(w,q,z,g,_),n._backpressure=void 0,n._backpressureChangePromise=void 0,n._backpressureChangePromise_resolve=void 0,xt(n,!0),n._transformStreamController=void 0}u(Bi,"InitializeTransformStream");function io(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_transformStreamController")?!1:n instanceof Ye}u(io,"IsTransformStream");function Mt(n,o){we(n._readable._readableStreamController,o),Ut(n,o)}u(Mt,"TransformStreamError");function Ut(n,o){so(n._transformStreamController),_r(n._writable._writableStreamController,o),n._backpressure&&xt(n,!1)}u(Ut,"TransformStreamErrorWritableAndUnblockWrite");function xt(n,o){n._backpressureChangePromise!==void 0&&n._backpressureChangePromise_resolve(),n._backpressureChangePromise=F(a=>{n._backpressureChangePromise_resolve=a}),n._backpressure=o}u(xt,"TransformStreamSetBackpressure");const Ur=class Ur{constructor(){throw new TypeError("Illegal constructor")}get desiredSize(){if(!Nt(this))throw Ht("desiredSize");const o=this._controlledTransformStream._readable._readableStreamController;return Pr(o)}enqueue(o=void 0){if(!Nt(this))throw Ht("enqueue");ao(this,o)}error(o=void 0){if(!Nt(this))throw Ht("error");Oi(this,o)}terminate(){if(!Nt(this))throw Ht("terminate");qi(this)}};u(Ur,"TransformStreamDefaultController");let Ie=Ur;Object.defineProperties(Ie.prototype,{enqueue:{enumerable:!0},error:{enumerable:!0},terminate:{enumerable:!0},desiredSize:{enumerable:!0}}),typeof b.toStringTag=="symbol"&&Object.defineProperty(Ie.prototype,b.toStringTag,{value:"TransformStreamDefaultController",configurable:!0});function Nt(n){return!C(n)||!Object.prototype.hasOwnProperty.call(n,"_controlledTransformStream")?!1:n instanceof Ie}u(Nt,"IsTransformStreamDefaultController");function Wi(n,o,a,p){o._controlledTransformStream=n,n._transformStreamController=o,o._transformAlgorithm=a,o._flushAlgorithm=p}u(Wi,"SetUpTransformStreamDefaultController");function ki(n,o){const a=Object.create(Ie.prototype);let p=u(_=>{try{return ao(a,_),T(void 0)}catch(w){return v(w)}},"transformAlgorithm"),g=u(()=>T(void 0),"flushAlgorithm");o.transform!==void 0&&(p=u(_=>o.transform(_,a),"transformAlgorithm")),o.flush!==void 0&&(g=u(()=>o.flush(a),"flushAlgorithm")),Wi(n,a,p,g)}u(ki,"SetUpTransformStreamDefaultControllerFromTransformer");function so(n){n._transformAlgorithm=void 0,n._flushAlgorithm=void 0}u(so,"TransformStreamDefaultControllerClearAlgorithms");function ao(n,o){const a=n._controlledTransformStream,p=a._readable._readableStreamController;if(!Ve(p))throw new TypeError("Readable side is not in a state that permits enqueue");try{$t(p,o)}catch(_){throw Ut(a,_),a._readable._storedError}fi(p)!==a._backpressure&&xt(a,!0)}u(ao,"TransformStreamDefaultControllerEnqueue");function Oi(n,o){Mt(n._controlledTransformStream,o)}u(Oi,"TransformStreamDefaultControllerError");function uo(n,o){const a=n._transformAlgorithm(o);return $(a,void 0,p=>{throw Mt(n._controlledTransformStream,p),p})}u(uo,"TransformStreamDefaultControllerPerformTransform");function qi(n){const o=n._controlledTransformStream,a=o._readable._readableStreamController;lt(a);const p=new TypeError("TransformStream terminated");Ut(o,p)}u(qi,"TransformStreamDefaultControllerTerminate");function zi(n,o){const a=n._transformStreamController;if(n._backpressure){const p=n._backpressureChangePromise;return $(p,()=>{const g=n._writable;if(g._state==="erroring")throw g._storedError;return uo(a,o)})}return uo(a,o)}u(zi,"TransformStreamDefaultSinkWriteAlgorithm");function Fi(n,o){return Mt(n,o),T(void 0)}u(Fi,"TransformStreamDefaultSinkAbortAlgorithm");function ji(n){const o=n._readable,a=n._transformStreamController,p=a._flushAlgorithm();return so(a),$(p,()=>{if(o._state==="errored")throw o._storedError;lt(o._readableStreamController)},g=>{throw Mt(n,g),o._storedError})}u(ji,"TransformStreamDefaultSinkCloseAlgorithm");function Ii(n){return xt(n,!1),n._backpressureChangePromise}u(Ii,"TransformStreamDefaultSourcePullAlgorithm");function Ht(n){return new TypeError(`TransformStreamDefaultController.prototype.${n} can only be used on a TransformStreamDefaultController`)}u(Ht,"defaultControllerBrandCheckException");function lo(n){return new TypeError(`TransformStream.prototype.${n} can only be used on a TransformStream`)}u(lo,"streamBrandCheckException"),d.ByteLengthQueuingStrategy=Qe,d.CountQueuingStrategy=Ge,d.ReadableByteStreamController=ge,d.ReadableStream=ae,d.ReadableStreamBYOBReader=We,d.ReadableStreamBYOBRequest=Ee,d.ReadableStreamDefaultController=Se,d.ReadableStreamDefaultReader=ve,d.TransformStream=Ye,d.TransformStreamDefaultController=Ie,d.WritableStream=Oe,d.WritableStreamDefaultController=_e,d.WritableStreamDefaultWriter=qe,Object.defineProperty(d,"__esModule",{value:!0})})}(ponyfill_es2018,ponyfill_es2018.exports)),ponyfill_es2018.exports}u(requirePonyfill_es2018,"requirePonyfill_es2018");const POOL_SIZE$1=65536;if(!globalThis.ReadableStream)try{const c=require("node:process"),{emitWarning:l}=c;try{c.emitWarning=()=>{},Object.assign(globalThis,require("node:stream/web")),c.emitWarning=l}catch(d){throw c.emitWarning=l,d}}catch{Object.assign(globalThis,requirePonyfill_es2018())}try{const{Blob:c}=require("buffer");c&&!c.prototype.stream&&(c.prototype.stream=u(function(d){let b=0;const y=this;return new ReadableStream({type:"bytes",async pull(S){const C=await y.slice(b,Math.min(y.size,b+POOL_SIZE$1)).arrayBuffer();b+=C.byteLength,S.enqueue(new Uint8Array(C)),b===y.size&&S.close()}})},"name"))}catch{}/*! fetch-blob. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */const POOL_SIZE=65536;async function*toIterator(c,l=!0){for(const d of c)if("stream"in d)yield*d.stream();else if(ArrayBuffer.isView(d))if(l){let b=d.byteOffset;const y=d.byteOffset+d.byteLength;for(;b!==y;){const S=Math.min(y-b,POOL_SIZE),R=d.buffer.slice(b,b+S);b+=R.byteLength,yield new Uint8Array(R)}}else yield d;else{let b=0,y=d;for(;b!==y.size;){const R=await y.slice(b,Math.min(y.size,b+POOL_SIZE)).arrayBuffer();b+=R.byteLength,yield new Uint8Array(R)}}}u(toIterator,"toIterator");const _Blob=(Me=class{constructor(l=[],d={}){ue(this,be,[]);ue(this,ct,"");ue(this,et,0);ue(this,Qt,"transparent");if(typeof l!="object"||l===null)throw new TypeError("Failed to construct 'Blob': The provided value cannot be converted to a sequence.");if(typeof l[Symbol.iterator]!="function")throw new TypeError("Failed to construct 'Blob': The object must have a callable @@iterator property.");if(typeof d!="object"&&typeof d!="function")throw new TypeError("Failed to construct 'Blob': parameter 2 cannot convert to dictionary.");d===null&&(d={});const b=new TextEncoder;for(const S of l){let R;ArrayBuffer.isView(S)?R=new Uint8Array(S.buffer.slice(S.byteOffset,S.byteOffset+S.byteLength)):S instanceof ArrayBuffer?R=new Uint8Array(S.slice(0)):S instanceof Me?R=S:R=b.encode(`${S}`),J(this,et,L(this,et)+(ArrayBuffer.isView(R)?R.byteLength:R.size)),L(this,be).push(R)}J(this,Qt,`${d.endings===void 0?"transparent":d.endings}`);const y=d.type===void 0?"":String(d.type);J(this,ct,/^[\x20-\x7E]*$/.test(y)?y:"")}get size(){return L(this,et)}get type(){return L(this,ct)}async text(){const l=new TextDecoder;let d="";for await(const b of toIterator(L(this,be),!1))d+=l.decode(b,{stream:!0});return d+=l.decode(),d}async arrayBuffer(){const l=new Uint8Array(this.size);let d=0;for await(const b of toIterator(L(this,be),!1))l.set(b,d),d+=b.length;return l.buffer}stream(){const l=toIterator(L(this,be),!0);return new globalThis.ReadableStream({type:"bytes",async pull(d){const b=await l.next();b.done?d.close():d.enqueue(b.value)},async cancel(){await l.return()}})}slice(l=0,d=this.size,b=""){const{size:y}=this;let S=l<0?Math.max(y+l,0):Math.min(l,y),R=d<0?Math.max(y+d,0):Math.min(d,y);const C=Math.max(R-S,0),O=L(this,be),A=[];let N=0;for(const H of O){if(N>=C)break;const F=ArrayBuffer.isView(H)?H.byteLength:H.size;if(S&&F<=S)S-=F,R-=F;else{let T;ArrayBuffer.isView(H)?(T=H.subarray(S,Math.min(F,R)),N+=T.byteLength):(T=H.slice(S,Math.min(F,R)),N+=T.size),R-=F,A.push(T),S=0}}const oe=new Me([],{type:String(b).toLowerCase()});return J(oe,et,C),J(oe,be,A),oe}get[Symbol.toStringTag](){return"Blob"}static[Symbol.hasInstance](l){return l&&typeof l=="object"&&typeof l.constructor=="function"&&(typeof l.stream=="function"||typeof l.arrayBuffer=="function")&&/^(Blob|File)$/.test(l[Symbol.toStringTag])}},be=new WeakMap,ct=new WeakMap,et=new WeakMap,Qt=new WeakMap,u(Me,"Blob"),Me);Object.defineProperties(_Blob.prototype,{size:{enumerable:!0},type:{enumerable:!0},slice:{enumerable:!0}});const Blob=_Blob,r$1=Blob,_File=(pt=class extends r$1{constructor(d,b,y={}){if(arguments.length<2)throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`);super(d,y);ue(this,dt,0);ue(this,ht,"");y===null&&(y={});const S=y.lastModified===void 0?Date.now():Number(y.lastModified);Number.isNaN(S)||J(this,dt,S),J(this,ht,String(b))}get name(){return L(this,ht)}get lastModified(){return L(this,dt)}get[Symbol.toStringTag](){return"File"}static[Symbol.hasInstance](d){return!!d&&d instanceof r$1&&/^(File)$/.test(d[Symbol.toStringTag])}},dt=new WeakMap,ht=new WeakMap,u(pt,"File"),pt),File=_File,File$1=File;/*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */var{toStringTag:t$1,iterator:i,hasInstance:h}=Symbol,r=Math.random,m="append,set,get,getAll,delete,keys,values,entries,forEach,constructor".split(","),f=u((c,l,d)=>(c+="",/^(Blob|File)$/.test(l&&l[t$1])?[(d=d!==void 0?d+"":l[t$1]=="File"?l.name:"blob",c),l.name!==d||l[t$1]=="blob"?new File$1([l],d,l):l]:[c,l+""]),"f"),e$1=u((c,l)=>(l?c:c.replace(/\r?\n|\r/g,`\r
`)).replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22"),"e$1"),x=u((c,l,d)=>{if(l.length<d)throw new TypeError(`Failed to execute '${c}' on 'FormData': ${d} arguments required, but only ${l.length} present.`)},"x");const FormData=(bt=class{constructor(...l){ue(this,X,[]);if(l.length)throw new TypeError("Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.")}get[t$1](){return"FormData"}[i](){return this.entries()}static[h](l){return l&&typeof l=="object"&&l[t$1]==="FormData"&&!m.some(d=>typeof l[d]!="function")}append(...l){x("append",arguments,2),L(this,X).push(f(...l))}delete(l){x("delete",arguments,1),l+="",J(this,X,L(this,X).filter(([d])=>d!==l))}get(l){x("get",arguments,1),l+="";for(var d=L(this,X),b=d.length,y=0;y<b;y++)if(d[y][0]===l)return d[y][1];return null}getAll(l,d){return x("getAll",arguments,1),d=[],l+="",L(this,X).forEach(b=>b[0]===l&&d.push(b[1])),d}has(l){return x("has",arguments,1),l+="",L(this,X).some(d=>d[0]===l)}forEach(l,d){x("forEach",arguments,1);for(var[b,y]of this)l.call(d,y,b,this)}set(...l){x("set",arguments,2);var d=[],b=!0;l=f(...l),L(this,X).forEach(y=>{y[0]===l[0]?b&&(b=!d.push(l)):d.push(y)}),b&&d.push(l),J(this,X,d)}*entries(){yield*L(this,X)}*keys(){for(var[l]of this)yield l}*values(){for(var[,l]of this)yield l}},X=new WeakMap,u(bt,"FormData"),bt);function formDataToBlob(c,l=r$1){var d=`${r()}${r()}`.replace(/\./g,"").slice(-28).padStart(32,"-"),b=[],y=`--${d}\r
Content-Disposition: form-data; name="`;return c.forEach((S,R)=>typeof S=="string"?b.push(y+e$1(R)+`"\r
\r
${S.replace(/\r(?!\n)|(?<!\r)\n/g,`\r
`)}\r
`):b.push(y+e$1(R)+`"; filename="${e$1(S.name,1)}"\r
Content-Type: ${S.type||"application/octet-stream"}\r
\r
`,S,`\r
`)),b.push(`--${d}--`),new l(b,{type:"multipart/form-data; boundary="+d})}u(formDataToBlob,"formDataToBlob");const Nr=class Nr extends Error{constructor(l,d){super(l),Error.captureStackTrace(this,this.constructor),this.type=d}get name(){return this.constructor.name}get[Symbol.toStringTag](){return this.constructor.name}};u(Nr,"FetchBaseError");let FetchBaseError=Nr;const Hr=class Hr extends FetchBaseError{constructor(l,d,b){super(l,d),b&&(this.code=this.errno=b.code,this.erroredSysCall=b.syscall)}};u(Hr,"FetchError");let FetchError=Hr;const NAME=Symbol.toStringTag,isURLSearchParameters=u(c=>typeof c=="object"&&typeof c.append=="function"&&typeof c.delete=="function"&&typeof c.get=="function"&&typeof c.getAll=="function"&&typeof c.has=="function"&&typeof c.set=="function"&&typeof c.sort=="function"&&c[NAME]==="URLSearchParams","isURLSearchParameters"),isBlob=u(c=>c&&typeof c=="object"&&typeof c.arrayBuffer=="function"&&typeof c.type=="string"&&typeof c.stream=="function"&&typeof c.constructor=="function"&&/^(Blob|File)$/.test(c[NAME]),"isBlob"),isAbortSignal=u(c=>typeof c=="object"&&(c[NAME]==="AbortSignal"||c[NAME]==="EventTarget"),"isAbortSignal"),isDomainOrSubdomain=u((c,l)=>{const d=new URL(l).hostname,b=new URL(c).hostname;return d===b||d.endsWith(`.${b}`)},"isDomainOrSubdomain"),isSameProtocol=u((c,l)=>{const d=new URL(l).protocol,b=new URL(c).protocol;return d===b},"isSameProtocol"),pipeline=require$$1.promisify(Stream__default.pipeline),INTERNALS$2=Symbol("Body internals"),Vr=class Vr{constructor(l,{size:d=0}={}){let b=null;l===null?l=null:isURLSearchParameters(l)?l=node_buffer.Buffer.from(l.toString()):isBlob(l)||node_buffer.Buffer.isBuffer(l)||(require$$1.types.isAnyArrayBuffer(l)?l=node_buffer.Buffer.from(l):ArrayBuffer.isView(l)?l=node_buffer.Buffer.from(l.buffer,l.byteOffset,l.byteLength):l instanceof Stream__default||(l instanceof FormData?(l=formDataToBlob(l),b=l.type.split("=")[1]):l=node_buffer.Buffer.from(String(l))));let y=l;node_buffer.Buffer.isBuffer(l)?y=Stream__default.Readable.from(l):isBlob(l)&&(y=Stream__default.Readable.from(l.stream())),this[INTERNALS$2]={body:l,stream:y,boundary:b,disturbed:!1,error:null},this.size=d,l instanceof Stream__default&&l.on("error",S=>{const R=S instanceof FetchBaseError?S:new FetchError(`Invalid response body while trying to fetch ${this.url}: ${S.message}`,"system",S);this[INTERNALS$2].error=R})}get body(){return this[INTERNALS$2].stream}get bodyUsed(){return this[INTERNALS$2].disturbed}async arrayBuffer(){const{buffer:l,byteOffset:d,byteLength:b}=await consumeBody(this);return l.slice(d,d+b)}async formData(){const l=this.headers.get("content-type");if(l.startsWith("application/x-www-form-urlencoded")){const b=new FormData,y=new URLSearchParams(await this.text());for(const[S,R]of y)b.append(S,R);return b}const{toFormData:d}=await import("./chunks/multipart-parser.cjs");return d(this.body,l)}async blob(){const l=this.headers&&this.headers.get("content-type")||this[INTERNALS$2].body&&this[INTERNALS$2].body.type||"",d=await this.arrayBuffer();return new r$1([d],{type:l})}async json(){const l=await this.text();return JSON.parse(l)}async text(){const l=await consumeBody(this);return new TextDecoder().decode(l)}buffer(){return consumeBody(this)}};u(Vr,"Body");let Body=Vr;Body.prototype.buffer=require$$1.deprecate(Body.prototype.buffer,"Please use 'response.arrayBuffer()' instead of 'response.buffer()'","node-fetch#buffer"),Object.defineProperties(Body.prototype,{body:{enumerable:!0},bodyUsed:{enumerable:!0},arrayBuffer:{enumerable:!0},blob:{enumerable:!0},json:{enumerable:!0},text:{enumerable:!0},data:{get:require$$1.deprecate(()=>{},"data doesn't exist, use json(), text(), arrayBuffer(), or body instead","https://github.com/node-fetch/node-fetch/issues/1000 (response)")}});async function consumeBody(c){if(c[INTERNALS$2].disturbed)throw new TypeError(`body used already for: ${c.url}`);if(c[INTERNALS$2].disturbed=!0,c[INTERNALS$2].error)throw c[INTERNALS$2].error;const{body:l}=c;if(l===null||!(l instanceof Stream__default))return node_buffer.Buffer.alloc(0);const d=[];let b=0;try{for await(const y of l){if(c.size>0&&b+y.length>c.size){const S=new FetchError(`content size at ${c.url} over limit: ${c.size}`,"max-size");throw l.destroy(S),S}b+=y.length,d.push(y)}}catch(y){throw y instanceof FetchBaseError?y:new FetchError(`Invalid response body while trying to fetch ${c.url}: ${y.message}`,"system",y)}if(l.readableEnded===!0||l._readableState.ended===!0)try{return d.every(y=>typeof y=="string")?node_buffer.Buffer.from(d.join("")):node_buffer.Buffer.concat(d,b)}catch(y){throw new FetchError(`Could not create Buffer from response body for ${c.url}: ${y.message}`,"system",y)}else throw new FetchError(`Premature close of server response while trying to fetch ${c.url}`)}u(consumeBody,"consumeBody");const clone=u((c,l)=>{let d,b,{body:y}=c[INTERNALS$2];if(c.bodyUsed)throw new Error("cannot clone body after it is used");return y instanceof Stream__default&&typeof y.getBoundary!="function"&&(d=new Stream.PassThrough({highWaterMark:l}),b=new Stream.PassThrough({highWaterMark:l}),y.pipe(d),y.pipe(b),c[INTERNALS$2].stream=d,y=b),y},"clone"),getNonSpecFormDataBoundary=require$$1.deprecate(c=>c.getBoundary(),"form-data doesn't follow the spec and requires special treatment. Use alternative package","https://github.com/node-fetch/node-fetch/issues/1167"),extractContentType=u((c,l)=>c===null?null:typeof c=="string"?"text/plain;charset=UTF-8":isURLSearchParameters(c)?"application/x-www-form-urlencoded;charset=UTF-8":isBlob(c)?c.type||null:node_buffer.Buffer.isBuffer(c)||require$$1.types.isAnyArrayBuffer(c)||ArrayBuffer.isView(c)?null:c instanceof FormData?`multipart/form-data; boundary=${l[INTERNALS$2].boundary}`:c&&typeof c.getBoundary=="function"?`multipart/form-data;boundary=${getNonSpecFormDataBoundary(c)}`:c instanceof Stream__default?null:"text/plain;charset=UTF-8","extractContentType"),getTotalBytes=u(c=>{const{body:l}=c[INTERNALS$2];return l===null?0:isBlob(l)?l.size:node_buffer.Buffer.isBuffer(l)?l.length:l&&typeof l.getLengthSync=="function"&&l.hasKnownLength&&l.hasKnownLength()?l.getLengthSync():null},"getTotalBytes"),writeToStream=u(async(c,{body:l})=>{l===null?c.end():await pipeline(l,c)},"writeToStream"),validateHeaderName=typeof http__default.validateHeaderName=="function"?http__default.validateHeaderName:c=>{if(!/^[\^`\-\w!#$%&'*+.|~]+$/.test(c)){const l=new TypeError(`Header name must be a valid HTTP token [${c}]`);throw Object.defineProperty(l,"code",{value:"ERR_INVALID_HTTP_TOKEN"}),l}},validateHeaderValue=typeof http__default.validateHeaderValue=="function"?http__default.validateHeaderValue:(c,l)=>{if(/[^\t\u0020-\u007E\u0080-\u00FF]/.test(l)){const d=new TypeError(`Invalid character in header content ["${c}"]`);throw Object.defineProperty(d,"code",{value:"ERR_INVALID_CHAR"}),d}},Gt=class Gt extends URLSearchParams{constructor(l){let d=[];if(l instanceof Gt){const b=l.raw();for(const[y,S]of Object.entries(b))d.push(...S.map(R=>[y,R]))}else if(l!=null)if(typeof l=="object"&&!require$$1.types.isBoxedPrimitive(l)){const b=l[Symbol.iterator];if(b==null)d.push(...Object.entries(l));else{if(typeof b!="function")throw new TypeError("Header pairs must be iterable");d=[...l].map(y=>{if(typeof y!="object"||require$$1.types.isBoxedPrimitive(y))throw new TypeError("Each header pair must be an iterable object");return[...y]}).map(y=>{if(y.length!==2)throw new TypeError("Each header pair must be a name/value tuple");return[...y]})}}else throw new TypeError("Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)");return d=d.length>0?d.map(([b,y])=>(validateHeaderName(b),validateHeaderValue(b,String(y)),[String(b).toLowerCase(),String(y)])):void 0,super(d),new Proxy(this,{get(b,y,S){switch(y){case"append":case"set":return(R,C)=>(validateHeaderName(R),validateHeaderValue(R,String(C)),URLSearchParams.prototype[y].call(b,String(R).toLowerCase(),String(C)));case"delete":case"has":case"getAll":return R=>(validateHeaderName(R),URLSearchParams.prototype[y].call(b,String(R).toLowerCase()));case"keys":return()=>(b.sort(),new Set(URLSearchParams.prototype.keys.call(b)).keys());default:return Reflect.get(b,y,S)}}})}get[Symbol.toStringTag](){return this.constructor.name}toString(){return Object.prototype.toString.call(this)}get(l){const d=this.getAll(l);if(d.length===0)return null;let b=d.join(", ");return/^content-encoding$/i.test(l)&&(b=b.toLowerCase()),b}forEach(l,d=void 0){for(const b of this.keys())Reflect.apply(l,d,[this.get(b),b,this])}*values(){for(const l of this.keys())yield this.get(l)}*entries(){for(const l of this.keys())yield[l,this.get(l)]}[Symbol.iterator](){return this.entries()}raw(){return[...this.keys()].reduce((l,d)=>(l[d]=this.getAll(d),l),{})}[Symbol.for("nodejs.util.inspect.custom")](){return[...this.keys()].reduce((l,d)=>{const b=this.getAll(d);return d==="host"?l[d]=b[0]:l[d]=b.length>1?b:b[0],l},{})}};u(Gt,"Headers");let Headers=Gt;Object.defineProperties(Headers.prototype,["get","entries","forEach","values"].reduce((c,l)=>(c[l]={enumerable:!0},c),{}));function fromRawHeaders(c=[]){return new Headers(c.reduce((l,d,b,y)=>(b%2===0&&l.push(y.slice(b,b+2)),l),[]).filter(([l,d])=>{try{return validateHeaderName(l),validateHeaderValue(l,String(d)),!0}catch{return!1}}))}u(fromRawHeaders,"fromRawHeaders");const redirectStatus=new Set([301,302,303,307,308]),isRedirect=u(c=>redirectStatus.has(c),"isRedirect"),INTERNALS$1=Symbol("Response internals"),Le=class Le extends Body{constructor(l=null,d={}){super(l,d);const b=d.status!=null?d.status:200,y=new Headers(d.headers);if(l!==null&&!y.has("Content-Type")){const S=extractContentType(l,this);S&&y.append("Content-Type",S)}this[INTERNALS$1]={type:"default",url:d.url,status:b,statusText:d.statusText||"",headers:y,counter:d.counter,highWaterMark:d.highWaterMark}}get type(){return this[INTERNALS$1].type}get url(){return this[INTERNALS$1].url||""}get status(){return this[INTERNALS$1].status}get ok(){return this[INTERNALS$1].status>=200&&this[INTERNALS$1].status<300}get redirected(){return this[INTERNALS$1].counter>0}get statusText(){return this[INTERNALS$1].statusText}get headers(){return this[INTERNALS$1].headers}get highWaterMark(){return this[INTERNALS$1].highWaterMark}clone(){return new Le(clone(this,this.highWaterMark),{type:this.type,url:this.url,status:this.status,statusText:this.statusText,headers:this.headers,ok:this.ok,redirected:this.redirected,size:this.size,highWaterMark:this.highWaterMark})}static redirect(l,d=302){if(!isRedirect(d))throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');return new Le(null,{headers:{location:new URL(l).toString()},status:d})}static error(){const l=new Le(null,{status:0,statusText:""});return l[INTERNALS$1].type="error",l}static json(l=void 0,d={}){const b=JSON.stringify(l);if(b===void 0)throw new TypeError("data is not JSON serializable");const y=new Headers(d&&d.headers);return y.has("content-type")||y.set("content-type","application/json"),new Le(b,{...d,headers:y})}get[Symbol.toStringTag](){return"Response"}};u(Le,"Response");let Response=Le;Object.defineProperties(Response.prototype,{type:{enumerable:!0},url:{enumerable:!0},status:{enumerable:!0},ok:{enumerable:!0},redirected:{enumerable:!0},statusText:{enumerable:!0},headers:{enumerable:!0},clone:{enumerable:!0}});const getSearch=u(c=>{if(c.search)return c.search;const l=c.href.length-1,d=c.hash||(c.href[l]==="#"?"#":"");return c.href[l-d.length]==="?"?"?":""},"getSearch");function stripURLForUseAsAReferrer(c,l=!1){return c==null||(c=new URL(c),/^(about|blob|data):$/.test(c.protocol))?"no-referrer":(c.username="",c.password="",c.hash="",l&&(c.pathname="",c.search=""),c)}u(stripURLForUseAsAReferrer,"stripURLForUseAsAReferrer");const ReferrerPolicy=new Set(["","no-referrer","no-referrer-when-downgrade","same-origin","origin","strict-origin","origin-when-cross-origin","strict-origin-when-cross-origin","unsafe-url"]),DEFAULT_REFERRER_POLICY="strict-origin-when-cross-origin";function validateReferrerPolicy(c){if(!ReferrerPolicy.has(c))throw new TypeError(`Invalid referrerPolicy: ${c}`);return c}u(validateReferrerPolicy,"validateReferrerPolicy");function isOriginPotentiallyTrustworthy(c){if(/^(http|ws)s:$/.test(c.protocol))return!0;const l=c.host.replace(/(^\[)|(]$)/g,""),d=node_net.isIP(l);return d===4&&/^127\./.test(l)||d===6&&/^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(l)?!0:c.host==="localhost"||c.host.endsWith(".localhost")?!1:c.protocol==="file:"}u(isOriginPotentiallyTrustworthy,"isOriginPotentiallyTrustworthy");function isUrlPotentiallyTrustworthy(c){return/^about:(blank|srcdoc)$/.test(c)||c.protocol==="data:"||/^(blob|filesystem):$/.test(c.protocol)?!0:isOriginPotentiallyTrustworthy(c)}u(isUrlPotentiallyTrustworthy,"isUrlPotentiallyTrustworthy");function determineRequestsReferrer(c,{referrerURLCallback:l,referrerOriginCallback:d}={}){if(c.referrer==="no-referrer"||c.referrerPolicy==="")return null;const b=c.referrerPolicy;if(c.referrer==="about:client")return"no-referrer";const y=c.referrer;let S=stripURLForUseAsAReferrer(y),R=stripURLForUseAsAReferrer(y,!0);S.toString().length>4096&&(S=R),l&&(S=l(S)),d&&(R=d(R));const C=new URL(c.url);switch(b){case"no-referrer":return"no-referrer";case"origin":return R;case"unsafe-url":return S;case"strict-origin":return isUrlPotentiallyTrustworthy(S)&&!isUrlPotentiallyTrustworthy(C)?"no-referrer":R.toString();case"strict-origin-when-cross-origin":return S.origin===C.origin?S:isUrlPotentiallyTrustworthy(S)&&!isUrlPotentiallyTrustworthy(C)?"no-referrer":R;case"same-origin":return S.origin===C.origin?S:"no-referrer";case"origin-when-cross-origin":return S.origin===C.origin?S:R;case"no-referrer-when-downgrade":return isUrlPotentiallyTrustworthy(S)&&!isUrlPotentiallyTrustworthy(C)?"no-referrer":S;default:throw new TypeError(`Invalid referrerPolicy: ${b}`)}}u(determineRequestsReferrer,"determineRequestsReferrer");function parseReferrerPolicyFromHeader(c){const l=(c.get("referrer-policy")||"").split(/[,\s]+/);let d="";for(const b of l)b&&ReferrerPolicy.has(b)&&(d=b);return d}u(parseReferrerPolicyFromHeader,"parseReferrerPolicyFromHeader");const INTERNALS=Symbol("Request internals"),isRequest=u(c=>typeof c=="object"&&typeof c[INTERNALS]=="object","isRequest"),doBadDataWarn=require$$1.deprecate(()=>{},".data is not a valid RequestInit property, use .body instead","https://github.com/node-fetch/node-fetch/issues/1000 (request)"),Yt=class Yt extends Body{constructor(l,d={}){let b;if(isRequest(l)?b=new URL(l.url):(b=new URL(l),l={}),b.username!==""||b.password!=="")throw new TypeError(`${b} is an url with embedded credentials.`);let y=d.method||l.method||"GET";if(/^(delete|get|head|options|post|put)$/i.test(y)&&(y=y.toUpperCase()),!isRequest(d)&&"data"in d&&doBadDataWarn(),(d.body!=null||isRequest(l)&&l.body!==null)&&(y==="GET"||y==="HEAD"))throw new TypeError("Request with GET/HEAD method cannot have body");const S=d.body?d.body:isRequest(l)&&l.body!==null?clone(l):null;super(S,{size:d.size||l.size||0});const R=new Headers(d.headers||l.headers||{});if(S!==null&&!R.has("Content-Type")){const A=extractContentType(S,this);A&&R.set("Content-Type",A)}let C=isRequest(l)?l.signal:null;if("signal"in d&&(C=d.signal),C!=null&&!isAbortSignal(C))throw new TypeError("Expected signal to be an instanceof AbortSignal or EventTarget");let O=d.referrer==null?l.referrer:d.referrer;if(O==="")O="no-referrer";else if(O){const A=new URL(O);O=/^about:(\/\/)?client$/.test(A)?"client":A}else O=void 0;this[INTERNALS]={method:y,redirect:d.redirect||l.redirect||"follow",headers:R,parsedURL:b,signal:C,referrer:O},this.follow=d.follow===void 0?l.follow===void 0?20:l.follow:d.follow,this.compress=d.compress===void 0?l.compress===void 0?!0:l.compress:d.compress,this.counter=d.counter||l.counter||0,this.agent=d.agent||l.agent,this.highWaterMark=d.highWaterMark||l.highWaterMark||16384,this.insecureHTTPParser=d.insecureHTTPParser||l.insecureHTTPParser||!1,this.referrerPolicy=d.referrerPolicy||l.referrerPolicy||""}get method(){return this[INTERNALS].method}get url(){return node_url.format(this[INTERNALS].parsedURL)}get headers(){return this[INTERNALS].headers}get redirect(){return this[INTERNALS].redirect}get signal(){return this[INTERNALS].signal}get referrer(){if(this[INTERNALS].referrer==="no-referrer")return"";if(this[INTERNALS].referrer==="client")return"about:client";if(this[INTERNALS].referrer)return this[INTERNALS].referrer.toString()}get referrerPolicy(){return this[INTERNALS].referrerPolicy}set referrerPolicy(l){this[INTERNALS].referrerPolicy=validateReferrerPolicy(l)}clone(){return new Yt(this)}get[Symbol.toStringTag](){return"Request"}};u(Yt,"Request");let Request=Yt;Object.defineProperties(Request.prototype,{method:{enumerable:!0},url:{enumerable:!0},headers:{enumerable:!0},redirect:{enumerable:!0},clone:{enumerable:!0},signal:{enumerable:!0},referrer:{enumerable:!0},referrerPolicy:{enumerable:!0}});const getNodeRequestOptions=u(c=>{const{parsedURL:l}=c[INTERNALS],d=new Headers(c[INTERNALS].headers);d.has("Accept")||d.set("Accept","*/*");let b=null;if(c.body===null&&/^(post|put)$/i.test(c.method)&&(b="0"),c.body!==null){const C=getTotalBytes(c);typeof C=="number"&&!Number.isNaN(C)&&(b=String(C))}b&&d.set("Content-Length",b),c.referrerPolicy===""&&(c.referrerPolicy=DEFAULT_REFERRER_POLICY),c.referrer&&c.referrer!=="no-referrer"?c[INTERNALS].referrer=determineRequestsReferrer(c):c[INTERNALS].referrer="no-referrer",c[INTERNALS].referrer instanceof URL&&d.set("Referer",c.referrer),d.has("User-Agent")||d.set("User-Agent","node-fetch"),c.compress&&!d.has("Accept-Encoding")&&d.set("Accept-Encoding","gzip, deflate, br");let{agent:y}=c;typeof y=="function"&&(y=y(l));const S=getSearch(l),R={path:l.pathname+S,method:c.method,headers:d[Symbol.for("nodejs.util.inspect.custom")](),insecureHTTPParser:c.insecureHTTPParser,agent:y};return{parsedURL:l,options:R}},"getNodeRequestOptions"),Qr=class Qr extends FetchBaseError{constructor(l,d="aborted"){super(l,d)}};u(Qr,"AbortError");let AbortError=Qr;/*! node-domexception. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */if(!globalThis.DOMException)try{const{MessageChannel:c}=require("worker_threads"),l=new c().port1,d=new ArrayBuffer;l.postMessage(d,[d,d])}catch(c){c.constructor.name==="DOMException"&&(globalThis.DOMException=c.constructor)}var nodeDomexception=globalThis.DOMException;const DOMException$1=_commonjsHelpers.getDefaultExportFromCjs(nodeDomexception),{stat}=node_fs.promises,blobFromSync=u((c,l)=>fromBlob(node_fs.statSync(c),c,l),"blobFromSync"),blobFrom=u((c,l)=>stat(c).then(d=>fromBlob(d,c,l)),"blobFrom"),fileFrom=u((c,l)=>stat(c).then(d=>fromFile(d,c,l)),"fileFrom"),fileFromSync=u((c,l)=>fromFile(node_fs.statSync(c),c,l),"fileFromSync"),fromBlob=u((c,l,d="")=>new r$1([new BlobDataItem({path:l,size:c.size,lastModified:c.mtimeMs,start:0})],{type:d}),"fromBlob"),fromFile=u((c,l,d="")=>new File$1([new BlobDataItem({path:l,size:c.size,lastModified:c.mtimeMs,start:0})],node_path.basename(l),{type:d,lastModified:c.mtimeMs}),"fromFile"),Zt=class Zt{constructor(l){ue(this,$e,void 0);ue(this,De,void 0);J(this,$e,l.path),J(this,De,l.start),this.size=l.size,this.lastModified=l.lastModified}slice(l,d){return new Zt({path:L(this,$e),lastModified:this.lastModified,size:d-l,start:L(this,De)+l})}async*stream(){const{mtimeMs:l}=await stat(L(this,$e));if(l>this.lastModified)throw new DOMException$1("The requested file could not be read, typically due to permission problems that have occurred after a reference to a file was acquired.","NotReadableError");yield*node_fs.createReadStream(L(this,$e),{start:L(this,De),end:L(this,De)+this.size-1})}get[Symbol.toStringTag](){return"Blob"}};$e=new WeakMap,De=new WeakMap,u(Zt,"BlobDataItem");let BlobDataItem=Zt;const supportedSchemas=new Set(["data:","http:","https:"]);async function fetch$1(c,l){return new Promise((d,b)=>{const y=new Request(c,l),{parsedURL:S,options:R}=getNodeRequestOptions(y);if(!supportedSchemas.has(S.protocol))throw new TypeError(`node-fetch cannot load ${c}. URL scheme "${S.protocol.replace(/:$/,"")}" is not supported.`);if(S.protocol==="data:"){const T=dataUriToBuffer(y.url),v=new Response(T,{headers:{"Content-Type":T.typeFull}});d(v);return}const C=(S.protocol==="https:"?https__default:http__default).request,{signal:O}=y;let A=null;const N=u(()=>{const T=new AbortError("The operation was aborted.");b(T),y.body&&y.body instanceof Stream__default.Readable&&y.body.destroy(T),!(!A||!A.body)&&A.body.emit("error",T)},"abort");if(O&&O.aborted){N();return}const oe=u(()=>{N(),F()},"abortAndFinalize"),H=C(S.toString(),R);O&&O.addEventListener("abort",oe);const F=u(()=>{H.abort(),O&&O.removeEventListener("abort",oe)},"finalize");H.on("error",T=>{b(new FetchError(`request to ${y.url} failed, reason: ${T.message}`,"system",T)),F()}),fixResponseChunkedTransferBadEnding(H,T=>{A&&A.body&&A.body.destroy(T)}),process.version<"v14"&&H.on("socket",T=>{let v;T.prependListener("end",()=>{v=T._eventsCount}),T.prependListener("close",j=>{if(A&&v<T._eventsCount&&!j){const D=new Error("Premature close");D.code="ERR_STREAM_PREMATURE_CLOSE",A.body.emit("error",D)}})}),H.on("response",T=>{H.setTimeout(0);const v=fromRawHeaders(T.rawHeaders);if(isRedirect(T.statusCode)){const $=v.get("Location");let V=null;try{V=$===null?null:new URL($,y.url)}catch{if(y.redirect!=="manual"){b(new FetchError(`uri requested responds with an invalid redirect URL: ${$}`,"invalid-redirect")),F();return}}switch(y.redirect){case"error":b(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${y.url}`,"no-redirect")),F();return;case"manual":break;case"follow":{if(V===null)break;if(y.counter>=y.follow){b(new FetchError(`maximum redirect reached at: ${y.url}`,"max-redirect")),F();return}const U={headers:new Headers(y.headers),follow:y.follow,counter:y.counter+1,agent:y.agent,compress:y.compress,method:y.method,body:clone(y),signal:y.signal,size:y.size,referrer:y.referrer,referrerPolicy:y.referrerPolicy};if(!isDomainOrSubdomain(y.url,V)||!isSameProtocol(y.url,V))for(const le of["authorization","www-authenticate","cookie","cookie2"])U.headers.delete(le);if(T.statusCode!==303&&y.body&&l.body instanceof Stream__default.Readable){b(new FetchError("Cannot follow redirect with body being a readable stream","unsupported-redirect")),F();return}(T.statusCode===303||(T.statusCode===301||T.statusCode===302)&&y.method==="POST")&&(U.method="GET",U.body=void 0,U.headers.delete("content-length"));const Pe=parseReferrerPolicyFromHeader(v);Pe&&(U.referrerPolicy=Pe),d(fetch$1(new Request(V,U))),F();return}default:return b(new TypeError(`Redirect option '${y.redirect}' is not a valid value of RequestRedirect`))}}O&&T.once("end",()=>{O.removeEventListener("abort",oe)});let j=Stream.pipeline(T,new Stream.PassThrough,$=>{$&&b($)});process.version<"v12.10"&&T.on("aborted",oe);const D={url:y.url,status:T.statusCode,statusText:T.statusMessage,headers:v,size:y.size,counter:y.counter,highWaterMark:y.highWaterMark},ie=v.get("Content-Encoding");if(!y.compress||y.method==="HEAD"||ie===null||T.statusCode===204||T.statusCode===304){A=new Response(j,D),d(A);return}const tt={flush:zlib__default.Z_SYNC_FLUSH,finishFlush:zlib__default.Z_SYNC_FLUSH};if(ie==="gzip"||ie==="x-gzip"){j=Stream.pipeline(j,zlib__default.createGunzip(tt),$=>{$&&b($)}),A=new Response(j,D),d(A);return}if(ie==="deflate"||ie==="x-deflate"){const $=Stream.pipeline(T,new Stream.PassThrough,V=>{V&&b(V)});$.once("data",V=>{(V[0]&15)===8?j=Stream.pipeline(j,zlib__default.createInflate(),U=>{U&&b(U)}):j=Stream.pipeline(j,zlib__default.createInflateRaw(),U=>{U&&b(U)}),A=new Response(j,D),d(A)}),$.once("end",()=>{A||(A=new Response(j,D),d(A))});return}if(ie==="br"){j=Stream.pipeline(j,zlib__default.createBrotliDecompress(),$=>{$&&b($)}),A=new Response(j,D),d(A);return}A=new Response(j,D),d(A)}),writeToStream(H,y).catch(b)})}u(fetch$1,"fetch$1");function fixResponseChunkedTransferBadEnding(c,l){const d=node_buffer.Buffer.from(`0\r
\r
`);let b=!1,y=!1,S;c.on("response",R=>{const{headers:C}=R;b=C["transfer-encoding"]==="chunked"&&!C["content-length"]}),c.on("socket",R=>{const C=u(()=>{if(b&&!y){const A=new Error("Premature close");A.code="ERR_STREAM_PREMATURE_CLOSE",l(A)}},"onSocketClose"),O=u(A=>{y=node_buffer.Buffer.compare(A.slice(-5),d)===0,!y&&S&&(y=node_buffer.Buffer.compare(S.slice(-3),d.slice(0,3))===0&&node_buffer.Buffer.compare(A.slice(-2),d.slice(3))===0),S=A},"onData");R.prependListener("close",C),R.on("data",O),c.on("close",()=>{R.removeListener("close",C),R.removeListener("data",O)})})}u(fixResponseChunkedTransferBadEnding,"fixResponseChunkedTransferBadEnding");const privateData=new WeakMap,wrappers=new WeakMap;function pd(c){const l=privateData.get(c);return console.assert(l!=null,"'this' is expected an Event object, but got",c),l}u(pd,"pd");function setCancelFlag(c){if(c.passiveListener!=null){typeof console<"u"&&typeof console.error=="function"&&console.error("Unable to preventDefault inside passive event listener invocation.",c.passiveListener);return}c.event.cancelable&&(c.canceled=!0,typeof c.event.preventDefault=="function"&&c.event.preventDefault())}u(setCancelFlag,"setCancelFlag");function Event(c,l){privateData.set(this,{eventTarget:c,event:l,eventPhase:2,currentTarget:c,canceled:!1,stopped:!1,immediateStopped:!1,passiveListener:null,timeStamp:l.timeStamp||Date.now()}),Object.defineProperty(this,"isTrusted",{value:!1,enumerable:!0});const d=Object.keys(l);for(let b=0;b<d.length;++b){const y=d[b];y in this||Object.defineProperty(this,y,defineRedirectDescriptor(y))}}u(Event,"Event"),Event.prototype={get type(){return pd(this).event.type},get target(){return pd(this).eventTarget},get currentTarget(){return pd(this).currentTarget},composedPath(){const c=pd(this).currentTarget;return c==null?[]:[c]},get NONE(){return 0},get CAPTURING_PHASE(){return 1},get AT_TARGET(){return 2},get BUBBLING_PHASE(){return 3},get eventPhase(){return pd(this).eventPhase},stopPropagation(){const c=pd(this);c.stopped=!0,typeof c.event.stopPropagation=="function"&&c.event.stopPropagation()},stopImmediatePropagation(){const c=pd(this);c.stopped=!0,c.immediateStopped=!0,typeof c.event.stopImmediatePropagation=="function"&&c.event.stopImmediatePropagation()},get bubbles(){return!!pd(this).event.bubbles},get cancelable(){return!!pd(this).event.cancelable},preventDefault(){setCancelFlag(pd(this))},get defaultPrevented(){return pd(this).canceled},get composed(){return!!pd(this).event.composed},get timeStamp(){return pd(this).timeStamp},get srcElement(){return pd(this).eventTarget},get cancelBubble(){return pd(this).stopped},set cancelBubble(c){if(!c)return;const l=pd(this);l.stopped=!0,typeof l.event.cancelBubble=="boolean"&&(l.event.cancelBubble=!0)},get returnValue(){return!pd(this).canceled},set returnValue(c){c||setCancelFlag(pd(this))},initEvent(){}},Object.defineProperty(Event.prototype,"constructor",{value:Event,configurable:!0,writable:!0}),typeof window<"u"&&typeof window.Event<"u"&&(Object.setPrototypeOf(Event.prototype,window.Event.prototype),wrappers.set(window.Event.prototype,Event));function defineRedirectDescriptor(c){return{get(){return pd(this).event[c]},set(l){pd(this).event[c]=l},configurable:!0,enumerable:!0}}u(defineRedirectDescriptor,"defineRedirectDescriptor");function defineCallDescriptor(c){return{value(){const l=pd(this).event;return l[c].apply(l,arguments)},configurable:!0,enumerable:!0}}u(defineCallDescriptor,"defineCallDescriptor");function defineWrapper(c,l){const d=Object.keys(l);if(d.length===0)return c;function b(y,S){c.call(this,y,S)}u(b,"CustomEvent"),b.prototype=Object.create(c.prototype,{constructor:{value:b,configurable:!0,writable:!0}});for(let y=0;y<d.length;++y){const S=d[y];if(!(S in c.prototype)){const C=typeof Object.getOwnPropertyDescriptor(l,S).value=="function";Object.defineProperty(b.prototype,S,C?defineCallDescriptor(S):defineRedirectDescriptor(S))}}return b}u(defineWrapper,"defineWrapper");function getWrapper(c){if(c==null||c===Object.prototype)return Event;let l=wrappers.get(c);return l==null&&(l=defineWrapper(getWrapper(Object.getPrototypeOf(c)),c),wrappers.set(c,l)),l}u(getWrapper,"getWrapper");function wrapEvent(c,l){const d=getWrapper(Object.getPrototypeOf(l));return new d(c,l)}u(wrapEvent,"wrapEvent");function isStopped(c){return pd(c).immediateStopped}u(isStopped,"isStopped");function setEventPhase(c,l){pd(c).eventPhase=l}u(setEventPhase,"setEventPhase");function setCurrentTarget(c,l){pd(c).currentTarget=l}u(setCurrentTarget,"setCurrentTarget");function setPassiveListener(c,l){pd(c).passiveListener=l}u(setPassiveListener,"setPassiveListener");const listenersMap=new WeakMap,CAPTURE=1,BUBBLE=2,ATTRIBUTE=3;function isObject(c){return c!==null&&typeof c=="object"}u(isObject,"isObject");function getListeners(c){const l=listenersMap.get(c);if(l==null)throw new TypeError("'this' is expected an EventTarget object, but got another value.");return l}u(getListeners,"getListeners");function defineEventAttributeDescriptor(c){return{get(){let d=getListeners(this).get(c);for(;d!=null;){if(d.listenerType===ATTRIBUTE)return d.listener;d=d.next}return null},set(l){typeof l!="function"&&!isObject(l)&&(l=null);const d=getListeners(this);let b=null,y=d.get(c);for(;y!=null;)y.listenerType===ATTRIBUTE?b!==null?b.next=y.next:y.next!==null?d.set(c,y.next):d.delete(c):b=y,y=y.next;if(l!==null){const S={listener:l,listenerType:ATTRIBUTE,passive:!1,once:!1,next:null};b===null?d.set(c,S):b.next=S}},configurable:!0,enumerable:!0}}u(defineEventAttributeDescriptor,"defineEventAttributeDescriptor");function defineEventAttribute(c,l){Object.defineProperty(c,`on${l}`,defineEventAttributeDescriptor(l))}u(defineEventAttribute,"defineEventAttribute");function defineCustomEventTarget(c){function l(){EventTarget.call(this)}u(l,"CustomEventTarget"),l.prototype=Object.create(EventTarget.prototype,{constructor:{value:l,configurable:!0,writable:!0}});for(let d=0;d<c.length;++d)defineEventAttribute(l.prototype,c[d]);return l}u(defineCustomEventTarget,"defineCustomEventTarget");function EventTarget(){if(this instanceof EventTarget){listenersMap.set(this,new Map);return}if(arguments.length===1&&Array.isArray(arguments[0]))return defineCustomEventTarget(arguments[0]);if(arguments.length>0){const c=new Array(arguments.length);for(let l=0;l<arguments.length;++l)c[l]=arguments[l];return defineCustomEventTarget(c)}throw new TypeError("Cannot call a class as a function")}u(EventTarget,"EventTarget"),EventTarget.prototype={addEventListener(c,l,d){if(l==null)return;if(typeof l!="function"&&!isObject(l))throw new TypeError("'listener' should be a function or an object.");const b=getListeners(this),y=isObject(d),R=(y?!!d.capture:!!d)?CAPTURE:BUBBLE,C={listener:l,listenerType:R,passive:y&&!!d.passive,once:y&&!!d.once,next:null};let O=b.get(c);if(O===void 0){b.set(c,C);return}let A=null;for(;O!=null;){if(O.listener===l&&O.listenerType===R)return;A=O,O=O.next}A.next=C},removeEventListener(c,l,d){if(l==null)return;const b=getListeners(this),S=(isObject(d)?!!d.capture:!!d)?CAPTURE:BUBBLE;let R=null,C=b.get(c);for(;C!=null;){if(C.listener===l&&C.listenerType===S){R!==null?R.next=C.next:C.next!==null?b.set(c,C.next):b.delete(c);return}R=C,C=C.next}},dispatchEvent(c){if(c==null||typeof c.type!="string")throw new TypeError('"event.type" should be a string.');const l=getListeners(this),d=c.type;let b=l.get(d);if(b==null)return!0;const y=wrapEvent(this,c);let S=null;for(;b!=null;){if(b.once?S!==null?S.next=b.next:b.next!==null?l.set(d,b.next):l.delete(d):S=b,setPassiveListener(y,b.passive?b.listener:null),typeof b.listener=="function")try{b.listener.call(this,y)}catch(R){typeof console<"u"&&typeof console.error=="function"&&console.error(R)}else b.listenerType!==ATTRIBUTE&&typeof b.listener.handleEvent=="function"&&b.listener.handleEvent(y);if(isStopped(y))break;b=b.next}return setPassiveListener(y,null),setEventPhase(y,0),setCurrentTarget(y,null),!y.defaultPrevented}},Object.defineProperty(EventTarget.prototype,"constructor",{value:EventTarget,configurable:!0,writable:!0}),typeof window<"u"&&typeof window.EventTarget<"u"&&Object.setPrototypeOf(EventTarget.prototype,window.EventTarget.prototype);const Gr=class Gr extends EventTarget{constructor(){throw super(),new TypeError("AbortSignal cannot be constructed directly")}get aborted(){const l=abortedFlags.get(this);if(typeof l!="boolean")throw new TypeError(`Expected 'this' to be an 'AbortSignal' object, but got ${this===null?"null":typeof this}`);return l}};u(Gr,"AbortSignal");let AbortSignal=Gr;defineEventAttribute(AbortSignal.prototype,"abort");function createAbortSignal(){const c=Object.create(AbortSignal.prototype);return EventTarget.call(c),abortedFlags.set(c,!1),c}u(createAbortSignal,"createAbortSignal");function abortSignal(c){abortedFlags.get(c)===!1&&(abortedFlags.set(c,!0),c.dispatchEvent({type:"abort"}))}u(abortSignal,"abortSignal");const abortedFlags=new WeakMap;Object.defineProperties(AbortSignal.prototype,{aborted:{enumerable:!0}}),typeof Symbol=="function"&&typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(AbortSignal.prototype,Symbol.toStringTag,{configurable:!0,value:"AbortSignal"});let AbortController$1=(mt=class{constructor(){signals.set(this,createAbortSignal())}get signal(){return getSignal(this)}abort(){abortSignal(getSignal(this))}},u(mt,"AbortController"),mt);const signals=new WeakMap;function getSignal(c){const l=signals.get(c);if(l==null)throw new TypeError(`Expected 'this' to be an 'AbortController' object, but got ${c===null?"null":typeof c}`);return l}u(getSignal,"getSignal"),Object.defineProperties(AbortController$1.prototype,{signal:{enumerable:!0},abort:{enumerable:!0}}),typeof Symbol=="function"&&typeof Symbol.toStringTag=="symbol"&&Object.defineProperty(AbortController$1.prototype,Symbol.toStringTag,{configurable:!0,value:"AbortController"});var t=Object.defineProperty,e=u((c,l)=>t(c,"name",{value:l,configurable:!0}),"e");const fetch=fetch$1;s();function s(){!globalThis.process?.versions?.node&&!globalThis.process?.env.DISABLE_NODE_FETCH_NATIVE_WARN&&console.warn("[node-fetch-native] Node.js compatible build of `node-fetch-native` is being used in a non-Node.js environment. Please make sure you are using proper export conditions or report this issue to https://github.com/unjs/node-fetch-native. You can set `process.env.DISABLE_NODE_FETCH_NATIVE_WARN` to disable this warning.")}u(s,"s"),e(s,"checkNodeEnvironment"),exports.AbortController=AbortController$1,exports.AbortError=AbortError,exports.Blob=r$1,exports.FetchError=FetchError,exports.File=File$1,exports.FormData=FormData,exports.Headers=Headers,exports.Request=Request,exports.Response=Response,exports.blobFrom=blobFrom,exports.blobFromSync=blobFromSync,exports.default=fetch,exports.fetch=fetch,exports.fileFrom=fileFrom,exports.fileFromSync=fileFromSync,exports.isRedirect=isRedirect;
